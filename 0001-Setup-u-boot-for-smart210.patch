From 14f5469c1005b688a84b3d667bd67425bce99038 Mon Sep 17 00:00:00 2001
From: dzhang <daniel.zhang@aviatnet.com>
Date: Tue, 5 Jan 2021 17:54:20 +1300
Subject: [PATCH] Setup u-boot for smart210

---
 u-boot/arch/arm/Kconfig                            |  10 +
 u-boot/arch/arm/Makefile                           |   1 +
 u-boot/arch/arm/cpu/armv7/Makefile                 |   2 +-
 u-boot/arch/arm/dts/Makefile                       |   1 +
 u-boot/arch/arm/dts/s5pv210-pinctrl.dtsi           | 274 +++++++
 u-boot/arch/arm/dts/s5pv210-smart210.dts           |  35 +
 u-boot/arch/arm/lib/crt0.S                         |   7 +-
 u-boot/arch/arm/mach-s5pv210/Kconfig               |  18 +
 u-boot/arch/arm/mach-s5pv210/Makefile              |  13 +
 u-boot/arch/arm/mach-s5pv210/cache.c               |  48 ++
 u-boot/arch/arm/mach-s5pv210/clock.c               | 326 ++++++++
 u-boot/arch/arm/mach-s5pv210/include/mach/clk.h    |  23 +
 u-boot/arch/arm/mach-s5pv210/include/mach/clock.h  |  52 ++
 u-boot/arch/arm/mach-s5pv210/include/mach/cpu.h    | 113 +++
 u-boot/arch/arm/mach-s5pv210/include/mach/dmc.h    |  58 ++
 u-boot/arch/arm/mach-s5pv210/include/mach/gpio.h   | 842 +++++++++++++++++++++
 u-boot/arch/arm/mach-s5pv210/include/mach/mmc.h    |  64 ++
 u-boot/arch/arm/mach-s5pv210/include/mach/periph.h |  60 ++
 u-boot/arch/arm/mach-s5pv210/include/mach/pinmux.h |  49 ++
 u-boot/arch/arm/mach-s5pv210/include/mach/power.h  |  27 +
 u-boot/arch/arm/mach-s5pv210/include/mach/pwm.h    |  54 ++
 u-boot/arch/arm/mach-s5pv210/include/mach/sromc.h  |  39 +
 .../arch/arm/mach-s5pv210/include/mach/sys_proto.h |  12 +
 u-boot/arch/arm/mach-s5pv210/include/mach/uart.h   |  43 ++
 .../arch/arm/mach-s5pv210/include/mach/watchdog.h  |  41 +
 u-boot/arch/arm/mach-s5pv210/pinmux.c              |  20 +
 u-boot/arch/arm/mach-s5pv210/reset.S               |  31 +
 u-boot/board/samsung/smart210/Kconfig              |  15 +
 u-boot/board/samsung/smart210/MAINTAINERS          |   6 +
 u-boot/board/samsung/smart210/Makefile             |  11 +
 u-boot/board/samsung/smart210/lowlevel_init.S      |  32 +
 u-boot/board/samsung/smart210/onenand.c            |  69 ++
 u-boot/board/samsung/smart210/smart210.c           | 190 +++++
 u-boot/common/spl/Kconfig                          |   4 +-
 u-boot/configs/smart210.h                          | 149 ++++
 u-boot/configs/smart210_defconfig                  |  30 +
 36 files changed, 2766 insertions(+), 3 deletions(-)
 create mode 100644 u-boot/arch/arm/dts/s5pv210-pinctrl.dtsi
 create mode 100644 u-boot/arch/arm/dts/s5pv210-smart210.dts
 create mode 100644 u-boot/arch/arm/mach-s5pv210/Kconfig
 create mode 100644 u-boot/arch/arm/mach-s5pv210/Makefile
 create mode 100644 u-boot/arch/arm/mach-s5pv210/cache.c
 create mode 100644 u-boot/arch/arm/mach-s5pv210/clock.c
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/clk.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/clock.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/cpu.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/dmc.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/gpio.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/mmc.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/periph.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/pinmux.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/power.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/pwm.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/sromc.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/sys_proto.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/uart.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/include/mach/watchdog.h
 create mode 100644 u-boot/arch/arm/mach-s5pv210/pinmux.c
 create mode 100644 u-boot/arch/arm/mach-s5pv210/reset.S
 create mode 100644 u-boot/board/samsung/smart210/Kconfig
 create mode 100644 u-boot/board/samsung/smart210/MAINTAINERS
 create mode 100644 u-boot/board/samsung/smart210/Makefile
 create mode 100644 u-boot/board/samsung/smart210/lowlevel_init.S
 create mode 100644 u-boot/board/samsung/smart210/onenand.c
 create mode 100644 u-boot/board/samsung/smart210/smart210.c
 create mode 100644 u-boot/configs/smart210.h
 create mode 100644 u-boot/configs/smart210_defconfig

diff --git a/u-boot/arch/arm/Kconfig b/u-boot/arch/arm/Kconfig
index fbe9087..e079597 100644
--- a/u-boot/arch/arm/Kconfig
+++ b/u-boot/arch/arm/Kconfig
@@ -750,6 +750,14 @@ config ARCH_S5PC1XX
 	select DM_SERIAL
 	imply CMD_DM
 
+config ARCH_S5PV210
+    bool "Samsung S5PV210"
+    select CPU_V7
+    select DM
+    select DM_SERIAL
+    select DM_GPIO
+    select DM_I2C
+
 config ARCH_HIGHBANK
 	bool "Calxeda Highbank"
 	select CPU_V7A
@@ -1933,6 +1941,8 @@ source "arch/arm/mach-rockchip/Kconfig"
 
 source "arch/arm/mach-s5pc1xx/Kconfig"
 
+source "arch/arm/mach-s5pv210/Kconfig"
+
 source "arch/arm/mach-snapdragon/Kconfig"
 
 source "arch/arm/mach-socfpga/Kconfig"
diff --git a/u-boot/arch/arm/Makefile b/u-boot/arch/arm/Makefile
index 28b523b..a19a8a6 100644
--- a/u-boot/arch/arm/Makefile
+++ b/u-boot/arch/arm/Makefile
@@ -73,6 +73,7 @@ machine-$(CONFIG_ARCH_OWL)		+= owl
 machine-$(CONFIG_ARCH_RMOBILE)		+= rmobile
 machine-$(CONFIG_ARCH_ROCKCHIP)		+= rockchip
 machine-$(CONFIG_ARCH_S5PC1XX)		+= s5pc1xx
+machine-$(CONFIG_ARCH_S5PV210)		+= s5pv210
 machine-$(CONFIG_ARCH_SNAPDRAGON)	+= snapdragon
 machine-$(CONFIG_ARCH_SOCFPGA)		+= socfpga
 machine-$(CONFIG_ARCH_STM32)		+= stm32
diff --git a/u-boot/arch/arm/cpu/armv7/Makefile b/u-boot/arch/arm/cpu/armv7/Makefile
index 0e83e39..a6a694d 100644
--- a/u-boot/arch/arm/cpu/armv7/Makefile
+++ b/u-boot/arch/arm/cpu/armv7/Makefile
@@ -29,7 +29,7 @@ obj-$(CONFIG_IPROC) += iproc-common/
 obj-$(CONFIG_KONA) += kona-common/
 obj-$(CONFIG_SYS_ARCH_TIMER) += arch_timer.o
 
-ifneq (,$(filter s5pc1xx exynos,$(SOC)))
+ifneq (,$(filter s5pv210 s5pc1xx exynos,$(SOC)))
 obj-y += s5p-common/
 endif
 
diff --git a/u-boot/arch/arm/dts/Makefile b/u-boot/arch/arm/dts/Makefile
index fd47e40..069a804 100644
--- a/u-boot/arch/arm/dts/Makefile
+++ b/u-boot/arch/arm/dts/Makefile
@@ -7,6 +7,7 @@ dtb-$(CONFIG_TARGET_GURNARD) += at91sam9g45-gurnard.dtb
 
 dtb-$(CONFIG_S5PC100) += s5pc1xx-smdkc100.dtb
 dtb-$(CONFIG_S5PC110) += s5pc1xx-goni.dtb
+dtb-$(CONFIG_S5PV210) += s5pv210-smart210.dtb
 dtb-$(CONFIG_EXYNOS4) += exynos4210-origen.dtb \
 	exynos4210-smdkv310.dtb \
 	exynos4210-universal_c210.dtb \
diff --git a/u-boot/arch/arm/dts/s5pv210-pinctrl.dtsi b/u-boot/arch/arm/dts/s5pv210-pinctrl.dtsi
new file mode 100644
index 0000000..ea97ca6
--- /dev/null
+++ b/u-boot/arch/arm/dts/s5pv210-pinctrl.dtsi
@@ -0,0 +1,274 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * U-Boot additions to enable a generic Exynos GPIO driver
+ *
+ * Copyright (c) 2014 Google, Inc
+ */
+
+/ {
+	pinctrl@e0200000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		gpa0: gpa0 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpa1: gpa1 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpb: gpb {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpc0: gpc0 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpc1: gpc1 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpd0: gpd0 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpd1: gpd1 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpe0: gpe0 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpe1: gpe1 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpf0: gpf0 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpf1: gpf1 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpf2: gpf2 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpf3: gpf3 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpg0: gpg0 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpg1: gpg1 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpg2: gpg2 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpg3: gpg3 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpi: gpi {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpj0: gpj0 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpj1: gpj1 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpj2: gpj2 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpj3: gpj3 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpj4: gpj4 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp01: gpmp01 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp02: gpmp02 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp03: gpmp03 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp04: gpmp04 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp05: gpmp05 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp06: gpmp06 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp07: gpmp07 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp10: gpmp10 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp11: gpmp11 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp12: gpmp12 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp13: gpmp13 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp14: gpmp14 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp15: gpmp15 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp16: gpmp16 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp17: gpmp17 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp18: gpmp18 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp20: gpmp20 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp21: gpmp21 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp22: gpmp22 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp23: gpmp23 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp24: gpmp24 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp25: gpmp25 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp26: gpmp26 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp27: gpmp27 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpmp28: gpmp28 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gph0: gph0 {
+			reg = <0xc00 0x20>;
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gph1: gph1 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gph2: gph2 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gph3: gph3 {
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+	};
+};
diff --git a/u-boot/arch/arm/dts/s5pv210-smart210.dts b/u-boot/arch/arm/dts/s5pv210-smart210.dts
new file mode 100644
index 0000000..7f11f3f
--- /dev/null
+++ b/u-boot/arch/arm/dts/s5pv210-smart210.dts
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Samsung's Exynos4210-based SMDKV310 board device tree source
+ *
+ * Copyright (c) 2014 Google, Inc
+ */
+
+/dts-v1/;
+
+#include "skeleton.dtsi"
+#include "s5pv210-pinctrl.dtsi"
+
+/ {
+	model = "Samsung SMART210 based on S5PV210";
+	compatible = "samsung,smart210", "samsung,s5pv210";
+
+	aliases {
+		serial0 = "/serial@e2900000";
+		console = "/serial@e2900000";
+		pinctrl0 = &pinctrl0;
+	};
+
+	pinctrl0: pinctrl@e0200000 {
+		compatible = "samsung,s5pv210-pinctrl";
+		reg = <0xe0200000 0x1000>;
+	};
+
+	serial@e2900000 {
+		compatible = "samsung,exynos4210-uart";
+		reg = <0xe2900000 0x100>;
+		interrupts = <0 51 0>;
+		id = <0>;
+	};
+
+};
diff --git a/u-boot/arch/arm/lib/crt0.S b/u-boot/arch/arm/lib/crt0.S
index 46b6be2..7265fca 100644
--- a/u-boot/arch/arm/lib/crt0.S
+++ b/u-boot/arch/arm/lib/crt0.S
@@ -114,7 +114,12 @@ ENTRY(_main)
 #endif
 
 	mov	r0, #0
-	bl	board_init_f
+#ifdef CONFIG_SPL_BUILD
+    bl      copy_bl2_to_ram
+    ldr pc, =CONFIG_SYS_SDRAM_BASE
+#else
+    bl      board_init_f
+#endif
 
 #if ! defined(CONFIG_SPL_BUILD)
 
diff --git a/u-boot/arch/arm/mach-s5pv210/Kconfig b/u-boot/arch/arm/mach-s5pv210/Kconfig
new file mode 100644
index 0000000..772223d
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/Kconfig
@@ -0,0 +1,18 @@
+if ARCH_S5PV210
+
+choice
+	prompt "S5PV210 board select"
+	optional
+
+config TARGET_SMART210
+	bool "Support smart210 board"
+	select OF_CONTROL
+
+endchoice
+
+config SYS_SOC
+	default "s5pv210"
+
+source "board/samsung/smart210/Kconfig"
+
+endif
diff --git a/u-boot/arch/arm/mach-s5pv210/Makefile b/u-boot/arch/arm/mach-s5pv210/Makefile
new file mode 100644
index 0000000..ab80460
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/Makefile
@@ -0,0 +1,13 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2008
+# Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+
+obj-y	= cache.o
+obj-y	+= reset.o
+
+obj-y	+= clock.o
+obj-y	+= pinmux.o
diff --git a/u-boot/arch/arm/mach-s5pv210/cache.c b/u-boot/arch/arm/mach-s5pv210/cache.c
new file mode 100644
index 0000000..b390bdf
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/cache.c
@@ -0,0 +1,48 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2014 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * Robert Baldyga <r.baldyga@samsung.com>
+ *
+ * based on arch/arm/cpu/armv7/omap3/cache.S
+ */
+
+#include <common.h>
+#include <cpu_func.h>
+#include <asm/cache.h>
+
+#if !CONFIG_IS_ENABLED(SYS_DCACHE_OFF)
+void enable_caches(void)
+{
+	dcache_enable();
+}
+
+void disable_caches(void)
+{
+	dcache_disable();
+}
+#endif
+
+#ifndef CONFIG_SYS_L2CACHE_OFF
+void v7_outer_cache_enable(void)
+{
+	__asm(
+		"push    {r0, r1, r2, lr}\n\t"
+		"mrc     15, 0, r3, cr1, cr0, 1\n\t"
+		"orr     r3, r3, #2\n\t"
+		"mcr     15, 0, r3, cr1, cr0, 1\n\t"
+		"pop     {r1, r2, r3, pc}"
+	);
+}
+
+void v7_outer_cache_disable(void)
+{
+	__asm(
+		"push    {r0, r1, r2, lr}\n\t"
+		"mrc     15, 0, r3, cr1, cr0, 1\n\t"
+		"bic     r3, r3, #2\n\t"
+		"mcr     15, 0, r3, cr1, cr0, 1\n\t"
+		"pop     {r1, r2, r3, pc}"
+	);
+}
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/clock.c b/u-boot/arch/arm/mach-s5pv210/clock.c
new file mode 100644
index 0000000..555228a
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/clock.c
@@ -0,0 +1,326 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2009 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * Heungjun Kim <riverful.kim@samsung.com>
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/clk.h>
+
+#define CLK_M	0
+#define CLK_D	1
+#define CLK_P	2
+
+#ifndef CONFIG_SYS_CLK_FREQ_C100
+#define CONFIG_SYS_CLK_FREQ_C100	12000000
+#endif
+#ifndef CONFIG_SYS_CLK_FREQ_C110
+#define CONFIG_SYS_CLK_FREQ_C110	24000000
+#endif
+
+/* s5pc110: return pll clock frequency */
+static unsigned long s5pc100_get_pll_clk(int pllreg)
+{
+	struct s5pc100_clock *clk =
+		(struct s5pc100_clock *)samsung_get_base_clock();
+	unsigned long r, m, p, s, mask, fout;
+	unsigned int freq;
+
+	switch (pllreg) {
+	case APLL:
+		r = readl(&clk->apll_con);
+		break;
+	case MPLL:
+		r = readl(&clk->mpll_con);
+		break;
+	case EPLL:
+		r = readl(&clk->epll_con);
+		break;
+	case HPLL:
+		r = readl(&clk->hpll_con);
+		break;
+	default:
+		printf("Unsupported PLL (%d)\n", pllreg);
+		return 0;
+	}
+
+	/*
+	 * APLL_CON: MIDV [25:16]
+	 * MPLL_CON: MIDV [23:16]
+	 * EPLL_CON: MIDV [23:16]
+	 * HPLL_CON: MIDV [23:16]
+	 */
+	if (pllreg == APLL)
+		mask = 0x3ff;
+	else
+		mask = 0x0ff;
+
+	m = (r >> 16) & mask;
+
+	/* PDIV [13:8] */
+	p = (r >> 8) & 0x3f;
+	/* SDIV [2:0] */
+	s = r & 0x7;
+
+	/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
+	freq = CONFIG_SYS_CLK_FREQ_C100;
+	fout = m * (freq / (p * (1 << s)));
+
+	return fout;
+}
+
+/* s5pc100: return pll clock frequency */
+static unsigned long s5pc110_get_pll_clk(int pllreg)
+{
+	struct s5pc110_clock *clk =
+		(struct s5pc110_clock *)samsung_get_base_clock();
+	unsigned long r, m, p, s, mask, fout;
+	unsigned int freq;
+
+	switch (pllreg) {
+	case APLL:
+		r = readl(&clk->apll_con);
+		break;
+	case MPLL:
+		r = readl(&clk->mpll_con);
+		break;
+	case EPLL:
+		r = readl(&clk->epll_con);
+		break;
+	case VPLL:
+		r = readl(&clk->vpll_con);
+		break;
+	default:
+		printf("Unsupported PLL (%d)\n", pllreg);
+		return 0;
+	}
+
+	/*
+	 * APLL_CON: MIDV [25:16]
+	 * MPLL_CON: MIDV [25:16]
+	 * EPLL_CON: MIDV [24:16]
+	 * VPLL_CON: MIDV [24:16]
+	 */
+	if (pllreg == APLL || pllreg == MPLL)
+		mask = 0x3ff;
+	else
+		mask = 0x1ff;
+
+	m = (r >> 16) & mask;
+
+	/* PDIV [13:8] */
+	p = (r >> 8) & 0x3f;
+	/* SDIV [2:0] */
+	s = r & 0x7;
+
+	freq = CONFIG_SYS_CLK_FREQ_C110;
+	if (pllreg == APLL) {
+		if (s < 1)
+			s = 1;
+		/* FOUT = MDIV * FIN / (PDIV * 2^(SDIV - 1)) */
+		fout = m * (freq / (p * (1 << (s - 1))));
+	} else
+		/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
+		fout = m * (freq / (p * (1 << s)));
+
+	return fout;
+}
+
+/* s5pc110: return ARM clock frequency */
+static unsigned long s5pc110_get_arm_clk(void)
+{
+	struct s5pc110_clock *clk =
+		(struct s5pc110_clock *)samsung_get_base_clock();
+	unsigned long div;
+	unsigned long dout_apll, armclk;
+	unsigned int apll_ratio;
+
+	div = readl(&clk->div0);
+
+	/* APLL_RATIO: [2:0] */
+	apll_ratio = div & 0x7;
+
+	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
+	armclk = dout_apll;
+
+	return armclk;
+}
+
+/* s5pc100: return ARM clock frequency */
+static unsigned long s5pc100_get_arm_clk(void)
+{
+	struct s5pc100_clock *clk =
+		(struct s5pc100_clock *)samsung_get_base_clock();
+	unsigned long div;
+	unsigned long dout_apll, armclk;
+	unsigned int apll_ratio, arm_ratio;
+
+	div = readl(&clk->div0);
+
+	/* ARM_RATIO: [6:4] */
+	arm_ratio = (div >> 4) & 0x7;
+	/* APLL_RATIO: [0] */
+	apll_ratio = div & 0x1;
+
+	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
+	armclk = dout_apll / (arm_ratio + 1);
+
+	return armclk;
+}
+
+/* s5pc100: return HCLKD0 frequency */
+static unsigned long get_hclk(void)
+{
+	struct s5pc100_clock *clk =
+		(struct s5pc100_clock *)samsung_get_base_clock();
+	unsigned long hclkd0;
+	uint div, d0_bus_ratio;
+
+	div = readl(&clk->div0);
+	/* D0_BUS_RATIO: [10:8] */
+	d0_bus_ratio = (div >> 8) & 0x7;
+
+	hclkd0 = get_arm_clk() / (d0_bus_ratio + 1);
+
+	return hclkd0;
+}
+
+/* s5pc100: return PCLKD1 frequency */
+static unsigned long get_pclkd1(void)
+{
+	struct s5pc100_clock *clk =
+		(struct s5pc100_clock *)samsung_get_base_clock();
+	unsigned long d1_bus, pclkd1;
+	uint div, d1_bus_ratio, pclkd1_ratio;
+
+	div = readl(&clk->div0);
+	/* D1_BUS_RATIO: [14:12] */
+	d1_bus_ratio = (div >> 12) & 0x7;
+	/* PCLKD1_RATIO: [18:16] */
+	pclkd1_ratio = (div >> 16) & 0x7;
+
+	/* ASYNC Mode */
+	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
+	pclkd1 = d1_bus / (pclkd1_ratio + 1);
+
+	return pclkd1;
+}
+
+/* s5pc110: return HCLKs frequency */
+static unsigned long get_hclk_sys(int dom)
+{
+	struct s5pc110_clock *clk =
+		(struct s5pc110_clock *)samsung_get_base_clock();
+	unsigned long hclk;
+	unsigned int div;
+	unsigned int offset;
+	unsigned int hclk_sys_ratio;
+
+	if (dom == CLK_M)
+		return get_hclk();
+
+	div = readl(&clk->div0);
+
+	/*
+	 * HCLK_MSYS_RATIO: [10:8]
+	 * HCLK_DSYS_RATIO: [19:16]
+	 * HCLK_PSYS_RATIO: [27:24]
+	 */
+	offset = 8 + (dom << 0x3);
+
+	hclk_sys_ratio = (div >> offset) & 0xf;
+
+	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
+
+	return hclk;
+}
+
+/* s5pc110: return PCLKs frequency */
+static unsigned long get_pclk_sys(int dom)
+{
+	struct s5pc110_clock *clk =
+		(struct s5pc110_clock *)samsung_get_base_clock();
+	unsigned long pclk;
+	unsigned int div;
+	unsigned int offset;
+	unsigned int pclk_sys_ratio;
+
+	div = readl(&clk->div0);
+
+	/*
+	 * PCLK_MSYS_RATIO: [14:12]
+	 * PCLK_DSYS_RATIO: [22:20]
+	 * PCLK_PSYS_RATIO: [30:28]
+	 */
+	offset = 12 + (dom << 0x3);
+
+	pclk_sys_ratio = (div >> offset) & 0x7;
+
+	pclk = get_hclk_sys(dom) / (pclk_sys_ratio + 1);
+
+	return pclk;
+}
+
+/* s5pc110: return peripheral clock frequency */
+static unsigned long s5pc110_get_pclk(void)
+{
+	return get_pclk_sys(CLK_P);
+}
+
+/* s5pc100: return peripheral clock frequency */
+static unsigned long s5pc100_get_pclk(void)
+{
+	return get_pclkd1();
+}
+
+/* s5pc1xx: return uart clock frequency */
+static unsigned long s5pc1xx_get_uart_clk(int dev_index)
+{
+	if (cpu_is_s5pc110())
+		return s5pc110_get_pclk();
+	else
+		return s5pc100_get_pclk();
+}
+
+/* s5pc1xx: return pwm clock frequency */
+static unsigned long s5pc1xx_get_pwm_clk(void)
+{
+	if (cpu_is_s5pc110())
+		return s5pc110_get_pclk();
+	else
+		return s5pc100_get_pclk();
+}
+
+unsigned long get_pll_clk(int pllreg)
+{
+	if (cpu_is_s5pc110())
+		return s5pc110_get_pll_clk(pllreg);
+	else
+		return s5pc100_get_pll_clk(pllreg);
+}
+
+unsigned long get_arm_clk(void)
+{
+	if (cpu_is_s5pc110())
+		return s5pc110_get_arm_clk();
+	else
+		return s5pc100_get_arm_clk();
+}
+
+unsigned long get_pwm_clk(void)
+{
+	return s5pc1xx_get_pwm_clk();
+}
+
+unsigned long get_uart_clk(int dev_index)
+{
+	return s5pc1xx_get_uart_clk(dev_index);
+}
+
+void set_mmc_clk(int dev_index, unsigned int div)
+{
+	/* Do NOTHING */
+}
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/clk.h b/u-boot/arch/arm/mach-s5pv210/include/mach/clk.h
new file mode 100644
index 0000000..8f22c0b
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/clk.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2009 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * Heungjun Kim <riverful.kim@samsung.com>
+ */
+
+#ifndef __ASM_ARM_ARCH_CLK_H_
+#define __ASM_ARM_ARCH_CLK_H_
+
+#define APLL	0
+#define MPLL	1
+#define EPLL	2
+#define HPLL	3
+#define VPLL	4
+
+unsigned long get_pll_clk(int pllreg);
+unsigned long get_arm_clk(void);
+unsigned long get_pwm_clk(void);
+unsigned long get_uart_clk(int dev_index);
+void set_mmc_clk(int dev_index, unsigned int div);
+
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/clock.h b/u-boot/arch/arm/mach-s5pv210/include/mach/clock.h
new file mode 100644
index 0000000..758e697
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/clock.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2009 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * Heungjun Kim <riverful.kim@samsung.com>
+ */
+
+#ifndef __ASM_ARM_ARCH_CLOCK_H_
+#define __ASM_ARM_ARCH_CLOCK_H_
+
+#ifndef __ASSEMBLY__
+struct s5pv210_clock {
+		unsigned int    apll_lock;
+		unsigned char   res1[0x04];
+		unsigned int    mpll_lock;
+		unsigned char   res2[0x04];
+		unsigned int    epll_lock;
+		unsigned char   res3[0x0C];
+		unsigned int    vpll_lock;
+		unsigned char   res4[0xdc];
+		unsigned int    apll_con0;
+		unsigned int    apll_con1;
+		unsigned int    mpll_con;
+		unsigned char   res5[0x04];
+		unsigned int    epll_con0;
+		unsigned int    epll_con1;
+		unsigned char   res6[0x08];
+		unsigned int    vpll_con;
+		unsigned char   res7[0xdc];
+		unsigned int    src0;
+		unsigned int    src1;
+		unsigned int    src2;
+		unsigned int    src3;
+		unsigned int    src4;
+		unsigned int    src5;
+		unsigned int    src6;
+		unsigned char   res8[0x64];
+		unsigned int    mask0;
+		unsigned int    mask1;
+		unsigned char   res9[0x78];
+		unsigned int    div0;
+		unsigned int    div1;
+		unsigned int    div2;
+		unsigned int    div3;
+		unsigned int    div4;
+		unsigned int    div5;
+		unsigned int    div6;
+		unsigned int    div7;
+};
+#endif
+
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/cpu.h b/u-boot/arch/arm/mach-s5pv210/include/mach/cpu.h
new file mode 100644
index 0000000..567d6a9
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/cpu.h
@@ -0,0 +1,113 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2009 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * Heungjun Kim <riverful.kim@samsung.com>
+ */
+
+#ifndef _S5PV210_CPU_H
+#define _S5PV210_CPU_H
+
+#define S5P_CPU_NAME		"S5P"
+#define S5PV210_ADDR_BASE	0xE0000000
+
+/* S5PV210 */  
+#define S5PV210_PRO_ID          0xE0000000  
+#define S5PV210_CLOCK_BASE      0xE0100000  
+#define S5PV210_GPIO_BASE       0xE0200000  
+#define S5PV210_PWMTIMER_BASE   0xE2500000  
+#define S5PV210_WATCHDOG_BASE   0xE2700000  
+#define S5PV210_UART_BASE       0xE2900000  
+#define S5PV210_MMC_BASE        0xEB000000  
+#define S5PV210_SROMC_BASE      0xE8000000  
+#define S5PV210_DMC0_BASE       0xF0000000  
+#define S5PV210_DMC1_BASE       0xF1400000  
+#define S5PV210_VIC0_BASE       0xF2000000  
+#define S5PV210_VIC1_BASE       0xF2100000  
+#define S5PV210_VIC2_BASE       0xF2200000  
+#define SPPV210_VIC3_BASE       0xF2300000  
+#define S5PV210_NAND_BASE       0xB0E00000 
+
+
+#ifndef __ASSEMBLY__
+#include <asm/io.h>
+/* CPU detection macros */
+extern unsigned int s5p_cpu_id;
+extern unsigned int s5p_cpu_rev;
+
+static inline int s5p_get_cpu_rev(void)
+{
+	return s5p_cpu_rev;
+}
+
+static inline void s5p_set_cpu_id(void)
+{
+	s5p_cpu_id = readl(S5PV210_PRO_ID);
+	s5p_cpu_rev = s5p_cpu_id & 0x000000FF;
+	s5p_cpu_id = 0xC000 | ((s5p_cpu_id & 0x00FFF000) >> 12);
+
+	int id = 0;  
+    s5p_cpu_id = readl(S5PV210_PRO_ID);  
+    s5p_cpu_rev = s5p_cpu_id & 0x000000FF;  
+    id = (s5p_cpu_id & 0xFFFFF000) >> 12;  
+    if (id == 0x43110) {
+        id = s5p_cpu_id & 0x0F;
+        switch (id){
+        case 0x00:
+            s5p_cpu_id = 0x56210;
+            break;  
+
+        case 0x01:
+            s5p_cpu_id = 0xc110;  
+               break;  
+
+        case 0x02:
+            s5p_cpu_id = 0xc111;
+            break;  
+
+        default :
+            break;
+        }
+    }
+}
+
+static inline char *s5p_get_cpu_name(void)
+{
+	return S5P_CPU_NAME;
+}
+
+#define IS_SAMSUNG_TYPE(type, id)			\
+static inline int cpu_is_##type(void)			\
+{							\
+	return s5p_cpu_id == id ? 1 : 0;		\
+}
+
+IS_SAMSUNG_TYPE(s5pv210, 0x56210)
+
+#define SAMSUNG_BASE(device, base)				\
+static inline unsigned int samsung_get_base_##device(void)	\
+{								\
+	if (cpu_is_s5pc100())					\
+		return S5PC100_##base;				\
+	else if (cpu_is_s5pc110())				\
+		return S5PC110_##base;				\
+	else if (cpu_is_s5pv210())				\
+        return S5PV210_##base;				\
+	else							\
+		return 0;					\
+}
+
+SAMSUNG_BASE(clock, CLOCK_BASE)
+SAMSUNG_BASE(gpio, GPIO_BASE)
+SAMSUNG_BASE(pro_id, PRO_ID)
+SAMSUNG_BASE(mmc, MMC_BASE)
+SAMSUNG_BASE(sromc, SROMC_BASE)
+SAMSUNG_BASE(timer, PWMTIMER_BASE)
+SAMSUNG_BASE(uart, UART_BASE)
+SAMSUNG_BASE(watchdog, WATCHDOG_BASE)
+
+SAMSUNG_BASE(dmc0, DMC0_BASE)
+SAMSUNG_BASE(dmc1, DMC1_BASE)
+#endif
+
+#endif	/* _S5PV210_CPU_H */
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/dmc.h b/u-boot/arch/arm/mach-s5pv210/include/mach/dmc.h
new file mode 100644
index 0000000..ac99473
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/dmc.h
@@ -0,0 +1,58 @@
+#ifndef __ASM_ARM_ARCH_DRAM_H_
+#define __ASM_ARM_ARCH_DRAM_H_
+
+#ifndef __ASSEMBLY__
+
+struct s5pv210_dmc0 {
+	unsigned int	concontrol;
+	unsigned int	memcontrol;
+	unsigned int	memconfig0;
+	unsigned int	memconfig1;
+	unsigned int	directcmd;
+	unsigned int	prechconfig;
+	unsigned int	phycontrol0;
+	unsigned int	phycontrol1;
+	unsigned char	res1[0x08];
+	unsigned int	pwrdnconfig;
+	unsigned char	res2[0x04];
+	unsigned int	timingaref;
+	unsigned int	timingrow;
+	unsigned int	timingdata;
+	unsigned int	timingpower;
+	unsigned int	phystatus;
+	unsigned int	chip0status;
+	unsigned int	chip1status;
+	unsigned int	arefstatus;
+	unsigned int	mrstatus;
+	unsigned int	phytest0;
+	unsigned int	phytest1;
+};
+
+struct s5pv210_dmc1 {
+	unsigned int	concontrol;
+	unsigned int	memcontrol;
+	unsigned int	memconfig0;
+	unsigned int	memconfig1;
+	unsigned int	directcmd;
+	unsigned int	prechconfig;
+	unsigned int	phycontrol0;
+	unsigned int	phycontrol1;
+	unsigned char	res1[0x08];
+	unsigned int	pwrdnconfig;
+	unsigned char	res2[0x04];
+	unsigned int	timingaref;
+	unsigned int	timingrow;
+	unsigned int	timingdata;
+	unsigned int	timingpower;
+	unsigned int	phystatus;
+	unsigned int	chip0status;
+	unsigned int	chip1status;
+	unsigned int	arefstatus;
+	unsigned int	mrstatus;
+	unsigned int	phytest0;
+	unsigned int	phytest1;
+};
+
+#endif
+
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/gpio.h b/u-boot/arch/arm/mach-s5pv210/include/mach/gpio.h
new file mode 100644
index 0000000..c8dfbdd
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/gpio.h
@@ -0,0 +1,842 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2009 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#ifndef __ASSEMBLY__
+struct s5p_gpio_bank {
+	unsigned int	con;
+	unsigned int	dat;
+	unsigned int	pull;
+	unsigned int	drv;
+	unsigned int	pdn_con;
+	unsigned int	pdn_pull;
+	unsigned char	res1[8];
+};
+
+/* A list of valid GPIO numbers for the asm-generic/gpio.h interface */
+enum s5pc100_gpio_pin {
+	S5PC100_GPIO_A00,
+	S5PC100_GPIO_A01,
+	S5PC100_GPIO_A02,
+	S5PC100_GPIO_A03,
+	S5PC100_GPIO_A04,
+	S5PC100_GPIO_A05,
+	S5PC100_GPIO_A06,
+	S5PC100_GPIO_A07,
+	S5PC100_GPIO_A10,
+	S5PC100_GPIO_A11,
+	S5PC100_GPIO_A12,
+	S5PC100_GPIO_A13,
+	S5PC100_GPIO_A14,
+	S5PC100_GPIO_A15,
+	S5PC100_GPIO_A16,
+	S5PC100_GPIO_A17,
+	S5PC100_GPIO_B0,
+	S5PC100_GPIO_B1,
+	S5PC100_GPIO_B2,
+	S5PC100_GPIO_B3,
+	S5PC100_GPIO_B4,
+	S5PC100_GPIO_B5,
+	S5PC100_GPIO_B6,
+	S5PC100_GPIO_B7,
+	S5PC100_GPIO_C0,
+	S5PC100_GPIO_C1,
+	S5PC100_GPIO_C2,
+	S5PC100_GPIO_C3,
+	S5PC100_GPIO_C4,
+	S5PC100_GPIO_C5,
+	S5PC100_GPIO_C6,
+	S5PC100_GPIO_C7,
+	S5PC100_GPIO_D0,
+	S5PC100_GPIO_D1,
+	S5PC100_GPIO_D2,
+	S5PC100_GPIO_D3,
+	S5PC100_GPIO_D4,
+	S5PC100_GPIO_D5,
+	S5PC100_GPIO_D6,
+	S5PC100_GPIO_D7,
+	S5PC100_GPIO_E00,
+	S5PC100_GPIO_E01,
+	S5PC100_GPIO_E02,
+	S5PC100_GPIO_E03,
+	S5PC100_GPIO_E04,
+	S5PC100_GPIO_E05,
+	S5PC100_GPIO_E06,
+	S5PC100_GPIO_E07,
+	S5PC100_GPIO_E10,
+	S5PC100_GPIO_E11,
+	S5PC100_GPIO_E12,
+	S5PC100_GPIO_E13,
+	S5PC100_GPIO_E14,
+	S5PC100_GPIO_E15,
+	S5PC100_GPIO_E16,
+	S5PC100_GPIO_E17,
+	S5PC100_GPIO_F00,
+	S5PC100_GPIO_F01,
+	S5PC100_GPIO_F02,
+	S5PC100_GPIO_F03,
+	S5PC100_GPIO_F04,
+	S5PC100_GPIO_F05,
+	S5PC100_GPIO_F06,
+	S5PC100_GPIO_F07,
+	S5PC100_GPIO_F10,
+	S5PC100_GPIO_F11,
+	S5PC100_GPIO_F12,
+	S5PC100_GPIO_F13,
+	S5PC100_GPIO_F14,
+	S5PC100_GPIO_F15,
+	S5PC100_GPIO_F16,
+	S5PC100_GPIO_F17,
+	S5PC100_GPIO_F20,
+	S5PC100_GPIO_F21,
+	S5PC100_GPIO_F22,
+	S5PC100_GPIO_F23,
+	S5PC100_GPIO_F24,
+	S5PC100_GPIO_F25,
+	S5PC100_GPIO_F26,
+	S5PC100_GPIO_F27,
+	S5PC100_GPIO_F30,
+	S5PC100_GPIO_F31,
+	S5PC100_GPIO_F32,
+	S5PC100_GPIO_F33,
+	S5PC100_GPIO_F34,
+	S5PC100_GPIO_F35,
+	S5PC100_GPIO_F36,
+	S5PC100_GPIO_F37,
+	S5PC100_GPIO_G00,
+	S5PC100_GPIO_G01,
+	S5PC100_GPIO_G02,
+	S5PC100_GPIO_G03,
+	S5PC100_GPIO_G04,
+	S5PC100_GPIO_G05,
+	S5PC100_GPIO_G06,
+	S5PC100_GPIO_G07,
+	S5PC100_GPIO_G10,
+	S5PC100_GPIO_G11,
+	S5PC100_GPIO_G12,
+	S5PC100_GPIO_G13,
+	S5PC100_GPIO_G14,
+	S5PC100_GPIO_G15,
+	S5PC100_GPIO_G16,
+	S5PC100_GPIO_G17,
+	S5PC100_GPIO_G20,
+	S5PC100_GPIO_G21,
+	S5PC100_GPIO_G22,
+	S5PC100_GPIO_G23,
+	S5PC100_GPIO_G24,
+	S5PC100_GPIO_G25,
+	S5PC100_GPIO_G26,
+	S5PC100_GPIO_G27,
+	S5PC100_GPIO_G30,
+	S5PC100_GPIO_G31,
+	S5PC100_GPIO_G32,
+	S5PC100_GPIO_G33,
+	S5PC100_GPIO_G34,
+	S5PC100_GPIO_G35,
+	S5PC100_GPIO_G36,
+	S5PC100_GPIO_G37,
+	S5PC100_GPIO_I0,
+	S5PC100_GPIO_I1,
+	S5PC100_GPIO_I2,
+	S5PC100_GPIO_I3,
+	S5PC100_GPIO_I4,
+	S5PC100_GPIO_I5,
+	S5PC100_GPIO_I6,
+	S5PC100_GPIO_I7,
+	S5PC100_GPIO_J00,
+	S5PC100_GPIO_J01,
+	S5PC100_GPIO_J02,
+	S5PC100_GPIO_J03,
+	S5PC100_GPIO_J04,
+	S5PC100_GPIO_J05,
+	S5PC100_GPIO_J06,
+	S5PC100_GPIO_J07,
+	S5PC100_GPIO_J10,
+	S5PC100_GPIO_J11,
+	S5PC100_GPIO_J12,
+	S5PC100_GPIO_J13,
+	S5PC100_GPIO_J14,
+	S5PC100_GPIO_J15,
+	S5PC100_GPIO_J16,
+	S5PC100_GPIO_J17,
+	S5PC100_GPIO_J20,
+	S5PC100_GPIO_J21,
+	S5PC100_GPIO_J22,
+	S5PC100_GPIO_J23,
+	S5PC100_GPIO_J24,
+	S5PC100_GPIO_J25,
+	S5PC100_GPIO_J26,
+	S5PC100_GPIO_J27,
+	S5PC100_GPIO_J30,
+	S5PC100_GPIO_J31,
+	S5PC100_GPIO_J32,
+	S5PC100_GPIO_J33,
+	S5PC100_GPIO_J34,
+	S5PC100_GPIO_J35,
+	S5PC100_GPIO_J36,
+	S5PC100_GPIO_J37,
+	S5PC100_GPIO_J40,
+	S5PC100_GPIO_J41,
+	S5PC100_GPIO_J42,
+	S5PC100_GPIO_J43,
+	S5PC100_GPIO_J44,
+	S5PC100_GPIO_J45,
+	S5PC100_GPIO_J46,
+	S5PC100_GPIO_J47,
+	S5PC100_GPIO_K00,
+	S5PC100_GPIO_K01,
+	S5PC100_GPIO_K02,
+	S5PC100_GPIO_K03,
+	S5PC100_GPIO_K04,
+	S5PC100_GPIO_K05,
+	S5PC100_GPIO_K06,
+	S5PC100_GPIO_K07,
+	S5PC100_GPIO_K10,
+	S5PC100_GPIO_K11,
+	S5PC100_GPIO_K12,
+	S5PC100_GPIO_K13,
+	S5PC100_GPIO_K14,
+	S5PC100_GPIO_K15,
+	S5PC100_GPIO_K16,
+	S5PC100_GPIO_K17,
+	S5PC100_GPIO_K20,
+	S5PC100_GPIO_K21,
+	S5PC100_GPIO_K22,
+	S5PC100_GPIO_K23,
+	S5PC100_GPIO_K24,
+	S5PC100_GPIO_K25,
+	S5PC100_GPIO_K26,
+	S5PC100_GPIO_K27,
+	S5PC100_GPIO_K30,
+	S5PC100_GPIO_K31,
+	S5PC100_GPIO_K32,
+	S5PC100_GPIO_K33,
+	S5PC100_GPIO_K34,
+	S5PC100_GPIO_K35,
+	S5PC100_GPIO_K36,
+	S5PC100_GPIO_K37,
+	S5PC100_GPIO_L00,
+	S5PC100_GPIO_L01,
+	S5PC100_GPIO_L02,
+	S5PC100_GPIO_L03,
+	S5PC100_GPIO_L04,
+	S5PC100_GPIO_L05,
+	S5PC100_GPIO_L06,
+	S5PC100_GPIO_L07,
+	S5PC100_GPIO_L10,
+	S5PC100_GPIO_L11,
+	S5PC100_GPIO_L12,
+	S5PC100_GPIO_L13,
+	S5PC100_GPIO_L14,
+	S5PC100_GPIO_L15,
+	S5PC100_GPIO_L16,
+	S5PC100_GPIO_L17,
+	S5PC100_GPIO_L20,
+	S5PC100_GPIO_L21,
+	S5PC100_GPIO_L22,
+	S5PC100_GPIO_L23,
+	S5PC100_GPIO_L24,
+	S5PC100_GPIO_L25,
+	S5PC100_GPIO_L26,
+	S5PC100_GPIO_L27,
+	S5PC100_GPIO_L30,
+	S5PC100_GPIO_L31,
+	S5PC100_GPIO_L32,
+	S5PC100_GPIO_L33,
+	S5PC100_GPIO_L34,
+	S5PC100_GPIO_L35,
+	S5PC100_GPIO_L36,
+	S5PC100_GPIO_L37,
+	S5PC100_GPIO_L40,
+	S5PC100_GPIO_L41,
+	S5PC100_GPIO_L42,
+	S5PC100_GPIO_L43,
+	S5PC100_GPIO_L44,
+	S5PC100_GPIO_L45,
+	S5PC100_GPIO_L46,
+	S5PC100_GPIO_L47,
+	S5PC100_GPIO_H00,
+	S5PC100_GPIO_H01,
+	S5PC100_GPIO_H02,
+	S5PC100_GPIO_H03,
+	S5PC100_GPIO_H04,
+	S5PC100_GPIO_H05,
+	S5PC100_GPIO_H06,
+	S5PC100_GPIO_H07,
+	S5PC100_GPIO_H10,
+	S5PC100_GPIO_H11,
+	S5PC100_GPIO_H12,
+	S5PC100_GPIO_H13,
+	S5PC100_GPIO_H14,
+	S5PC100_GPIO_H15,
+	S5PC100_GPIO_H16,
+	S5PC100_GPIO_H17,
+	S5PC100_GPIO_H20,
+	S5PC100_GPIO_H21,
+	S5PC100_GPIO_H22,
+	S5PC100_GPIO_H23,
+	S5PC100_GPIO_H24,
+	S5PC100_GPIO_H25,
+	S5PC100_GPIO_H26,
+	S5PC100_GPIO_H27,
+	S5PC100_GPIO_H30,
+	S5PC100_GPIO_H31,
+	S5PC100_GPIO_H32,
+	S5PC100_GPIO_H33,
+	S5PC100_GPIO_H34,
+	S5PC100_GPIO_H35,
+	S5PC100_GPIO_H36,
+	S5PC100_GPIO_H37,
+
+	S5PC100_GPIO_MAX_PORT
+};
+
+enum s5pc110_gpio_pin {
+	S5PC110_GPIO_A00,
+	S5PC110_GPIO_A01,
+	S5PC110_GPIO_A02,
+	S5PC110_GPIO_A03,
+	S5PC110_GPIO_A04,
+	S5PC110_GPIO_A05,
+	S5PC110_GPIO_A06,
+	S5PC110_GPIO_A07,
+	S5PC110_GPIO_A10,
+	S5PC110_GPIO_A11,
+	S5PC110_GPIO_A12,
+	S5PC110_GPIO_A13,
+	S5PC110_GPIO_A14,
+	S5PC110_GPIO_A15,
+	S5PC110_GPIO_A16,
+	S5PC110_GPIO_A17,
+	S5PC110_GPIO_B0,
+	S5PC110_GPIO_B1,
+	S5PC110_GPIO_B2,
+	S5PC110_GPIO_B3,
+	S5PC110_GPIO_B4,
+	S5PC110_GPIO_B5,
+	S5PC110_GPIO_B6,
+	S5PC110_GPIO_B7,
+	S5PC110_GPIO_C00,
+	S5PC110_GPIO_C01,
+	S5PC110_GPIO_C02,
+	S5PC110_GPIO_C03,
+	S5PC110_GPIO_C04,
+	S5PC110_GPIO_C05,
+	S5PC110_GPIO_C06,
+	S5PC110_GPIO_C07,
+	S5PC110_GPIO_C10,
+	S5PC110_GPIO_C11,
+	S5PC110_GPIO_C12,
+	S5PC110_GPIO_C13,
+	S5PC110_GPIO_C14,
+	S5PC110_GPIO_C15,
+	S5PC110_GPIO_C16,
+	S5PC110_GPIO_C17,
+	S5PC110_GPIO_D00,
+	S5PC110_GPIO_D01,
+	S5PC110_GPIO_D02,
+	S5PC110_GPIO_D03,
+	S5PC110_GPIO_D04,
+	S5PC110_GPIO_D05,
+	S5PC110_GPIO_D06,
+	S5PC110_GPIO_D07,
+	S5PC110_GPIO_D10,
+	S5PC110_GPIO_D11,
+	S5PC110_GPIO_D12,
+	S5PC110_GPIO_D13,
+	S5PC110_GPIO_D14,
+	S5PC110_GPIO_D15,
+	S5PC110_GPIO_D16,
+	S5PC110_GPIO_D17,
+	S5PC110_GPIO_E00,
+	S5PC110_GPIO_E01,
+	S5PC110_GPIO_E02,
+	S5PC110_GPIO_E03,
+	S5PC110_GPIO_E04,
+	S5PC110_GPIO_E05,
+	S5PC110_GPIO_E06,
+	S5PC110_GPIO_E07,
+	S5PC110_GPIO_E10,
+	S5PC110_GPIO_E11,
+	S5PC110_GPIO_E12,
+	S5PC110_GPIO_E13,
+	S5PC110_GPIO_E14,
+	S5PC110_GPIO_E15,
+	S5PC110_GPIO_E16,
+	S5PC110_GPIO_E17,
+	S5PC110_GPIO_F00,
+	S5PC110_GPIO_F01,
+	S5PC110_GPIO_F02,
+	S5PC110_GPIO_F03,
+	S5PC110_GPIO_F04,
+	S5PC110_GPIO_F05,
+	S5PC110_GPIO_F06,
+	S5PC110_GPIO_F07,
+	S5PC110_GPIO_F10,
+	S5PC110_GPIO_F11,
+	S5PC110_GPIO_F12,
+	S5PC110_GPIO_F13,
+	S5PC110_GPIO_F14,
+	S5PC110_GPIO_F15,
+	S5PC110_GPIO_F16,
+	S5PC110_GPIO_F17,
+	S5PC110_GPIO_F20,
+	S5PC110_GPIO_F21,
+	S5PC110_GPIO_F22,
+	S5PC110_GPIO_F23,
+	S5PC110_GPIO_F24,
+	S5PC110_GPIO_F25,
+	S5PC110_GPIO_F26,
+	S5PC110_GPIO_F27,
+	S5PC110_GPIO_F30,
+	S5PC110_GPIO_F31,
+	S5PC110_GPIO_F32,
+	S5PC110_GPIO_F33,
+	S5PC110_GPIO_F34,
+	S5PC110_GPIO_F35,
+	S5PC110_GPIO_F36,
+	S5PC110_GPIO_F37,
+	S5PC110_GPIO_G00,
+	S5PC110_GPIO_G01,
+	S5PC110_GPIO_G02,
+	S5PC110_GPIO_G03,
+	S5PC110_GPIO_G04,
+	S5PC110_GPIO_G05,
+	S5PC110_GPIO_G06,
+	S5PC110_GPIO_G07,
+	S5PC110_GPIO_G10,
+	S5PC110_GPIO_G11,
+	S5PC110_GPIO_G12,
+	S5PC110_GPIO_G13,
+	S5PC110_GPIO_G14,
+	S5PC110_GPIO_G15,
+	S5PC110_GPIO_G16,
+	S5PC110_GPIO_G17,
+	S5PC110_GPIO_G20,
+	S5PC110_GPIO_G21,
+	S5PC110_GPIO_G22,
+	S5PC110_GPIO_G23,
+	S5PC110_GPIO_G24,
+	S5PC110_GPIO_G25,
+	S5PC110_GPIO_G26,
+	S5PC110_GPIO_G27,
+	S5PC110_GPIO_G30,
+	S5PC110_GPIO_G31,
+	S5PC110_GPIO_G32,
+	S5PC110_GPIO_G33,
+	S5PC110_GPIO_G34,
+	S5PC110_GPIO_G35,
+	S5PC110_GPIO_G36,
+	S5PC110_GPIO_G37,
+	S5PC110_GPIO_I0,
+	S5PC110_GPIO_I1,
+	S5PC110_GPIO_I2,
+	S5PC110_GPIO_I3,
+	S5PC110_GPIO_I4,
+	S5PC110_GPIO_I5,
+	S5PC110_GPIO_I6,
+	S5PC110_GPIO_I7,
+	S5PC110_GPIO_J00,
+	S5PC110_GPIO_J01,
+	S5PC110_GPIO_J02,
+	S5PC110_GPIO_J03,
+	S5PC110_GPIO_J04,
+	S5PC110_GPIO_J05,
+	S5PC110_GPIO_J06,
+	S5PC110_GPIO_J07,
+	S5PC110_GPIO_J10,
+	S5PC110_GPIO_J11,
+	S5PC110_GPIO_J12,
+	S5PC110_GPIO_J13,
+	S5PC110_GPIO_J14,
+	S5PC110_GPIO_J15,
+	S5PC110_GPIO_J16,
+	S5PC110_GPIO_J17,
+	S5PC110_GPIO_J20,
+	S5PC110_GPIO_J21,
+	S5PC110_GPIO_J22,
+	S5PC110_GPIO_J23,
+	S5PC110_GPIO_J24,
+	S5PC110_GPIO_J25,
+	S5PC110_GPIO_J26,
+	S5PC110_GPIO_J27,
+	S5PC110_GPIO_J30,
+	S5PC110_GPIO_J31,
+	S5PC110_GPIO_J32,
+	S5PC110_GPIO_J33,
+	S5PC110_GPIO_J34,
+	S5PC110_GPIO_J35,
+	S5PC110_GPIO_J36,
+	S5PC110_GPIO_J37,
+	S5PC110_GPIO_J40,
+	S5PC110_GPIO_J41,
+	S5PC110_GPIO_J42,
+	S5PC110_GPIO_J43,
+	S5PC110_GPIO_J44,
+	S5PC110_GPIO_J45,
+	S5PC110_GPIO_J46,
+	S5PC110_GPIO_J47,
+	S5PC110_GPIO_MP010,
+	S5PC110_GPIO_MP011,
+	S5PC110_GPIO_MP012,
+	S5PC110_GPIO_MP013,
+	S5PC110_GPIO_MP014,
+	S5PC110_GPIO_MP015,
+	S5PC110_GPIO_MP016,
+	S5PC110_GPIO_MP017,
+	S5PC110_GPIO_MP020,
+	S5PC110_GPIO_MP021,
+	S5PC110_GPIO_MP022,
+	S5PC110_GPIO_MP023,
+	S5PC110_GPIO_MP024,
+	S5PC110_GPIO_MP025,
+	S5PC110_GPIO_MP026,
+	S5PC110_GPIO_MP027,
+	S5PC110_GPIO_MP030,
+	S5PC110_GPIO_MP031,
+	S5PC110_GPIO_MP032,
+	S5PC110_GPIO_MP033,
+	S5PC110_GPIO_MP034,
+	S5PC110_GPIO_MP035,
+	S5PC110_GPIO_MP036,
+	S5PC110_GPIO_MP037,
+	S5PC110_GPIO_MP040,
+	S5PC110_GPIO_MP041,
+	S5PC110_GPIO_MP042,
+	S5PC110_GPIO_MP043,
+	S5PC110_GPIO_MP044,
+	S5PC110_GPIO_MP045,
+	S5PC110_GPIO_MP046,
+	S5PC110_GPIO_MP047,
+	S5PC110_GPIO_MP050,
+	S5PC110_GPIO_MP051,
+	S5PC110_GPIO_MP052,
+	S5PC110_GPIO_MP053,
+	S5PC110_GPIO_MP054,
+	S5PC110_GPIO_MP055,
+	S5PC110_GPIO_MP056,
+	S5PC110_GPIO_MP057,
+	S5PC110_GPIO_MP060,
+	S5PC110_GPIO_MP061,
+	S5PC110_GPIO_MP062,
+	S5PC110_GPIO_MP063,
+	S5PC110_GPIO_MP064,
+	S5PC110_GPIO_MP065,
+	S5PC110_GPIO_MP066,
+	S5PC110_GPIO_MP067,
+	S5PC110_GPIO_MP070,
+	S5PC110_GPIO_MP071,
+	S5PC110_GPIO_MP072,
+	S5PC110_GPIO_MP073,
+	S5PC110_GPIO_MP074,
+	S5PC110_GPIO_MP075,
+	S5PC110_GPIO_MP076,
+	S5PC110_GPIO_MP077,
+	S5PC110_GPIO_MP100,
+	S5PC110_GPIO_MP101,
+	S5PC110_GPIO_MP102,
+	S5PC110_GPIO_MP103,
+	S5PC110_GPIO_MP104,
+	S5PC110_GPIO_MP105,
+	S5PC110_GPIO_MP106,
+	S5PC110_GPIO_MP107,
+	S5PC110_GPIO_MP110,
+	S5PC110_GPIO_MP111,
+	S5PC110_GPIO_MP112,
+	S5PC110_GPIO_MP113,
+	S5PC110_GPIO_MP114,
+	S5PC110_GPIO_MP115,
+	S5PC110_GPIO_MP116,
+	S5PC110_GPIO_MP117,
+	S5PC110_GPIO_MP120,
+	S5PC110_GPIO_MP121,
+	S5PC110_GPIO_MP122,
+	S5PC110_GPIO_MP123,
+	S5PC110_GPIO_MP124,
+	S5PC110_GPIO_MP125,
+	S5PC110_GPIO_MP126,
+	S5PC110_GPIO_MP127,
+	S5PC110_GPIO_MP130,
+	S5PC110_GPIO_MP131,
+	S5PC110_GPIO_MP132,
+	S5PC110_GPIO_MP133,
+	S5PC110_GPIO_MP134,
+	S5PC110_GPIO_MP135,
+	S5PC110_GPIO_MP136,
+	S5PC110_GPIO_MP137,
+	S5PC110_GPIO_MP140,
+	S5PC110_GPIO_MP141,
+	S5PC110_GPIO_MP142,
+	S5PC110_GPIO_MP143,
+	S5PC110_GPIO_MP144,
+	S5PC110_GPIO_MP145,
+	S5PC110_GPIO_MP146,
+	S5PC110_GPIO_MP147,
+	S5PC110_GPIO_MP150,
+	S5PC110_GPIO_MP151,
+	S5PC110_GPIO_MP152,
+	S5PC110_GPIO_MP153,
+	S5PC110_GPIO_MP154,
+	S5PC110_GPIO_MP155,
+	S5PC110_GPIO_MP156,
+	S5PC110_GPIO_MP157,
+	S5PC110_GPIO_MP160,
+	S5PC110_GPIO_MP161,
+	S5PC110_GPIO_MP162,
+	S5PC110_GPIO_MP163,
+	S5PC110_GPIO_MP164,
+	S5PC110_GPIO_MP165,
+	S5PC110_GPIO_MP166,
+	S5PC110_GPIO_MP167,
+	S5PC110_GPIO_MP170,
+	S5PC110_GPIO_MP171,
+	S5PC110_GPIO_MP172,
+	S5PC110_GPIO_MP173,
+	S5PC110_GPIO_MP174,
+	S5PC110_GPIO_MP175,
+	S5PC110_GPIO_MP176,
+	S5PC110_GPIO_MP177,
+	S5PC110_GPIO_MP180,
+	S5PC110_GPIO_MP181,
+	S5PC110_GPIO_MP182,
+	S5PC110_GPIO_MP183,
+	S5PC110_GPIO_MP184,
+	S5PC110_GPIO_MP185,
+	S5PC110_GPIO_MP186,
+	S5PC110_GPIO_MP187,
+	S5PC110_GPIO_MP200,
+	S5PC110_GPIO_MP201,
+	S5PC110_GPIO_MP202,
+	S5PC110_GPIO_MP203,
+	S5PC110_GPIO_MP204,
+	S5PC110_GPIO_MP205,
+	S5PC110_GPIO_MP206,
+	S5PC110_GPIO_MP207,
+	S5PC110_GPIO_MP210,
+	S5PC110_GPIO_MP211,
+	S5PC110_GPIO_MP212,
+	S5PC110_GPIO_MP213,
+	S5PC110_GPIO_MP214,
+	S5PC110_GPIO_MP215,
+	S5PC110_GPIO_MP216,
+	S5PC110_GPIO_MP217,
+	S5PC110_GPIO_MP220,
+	S5PC110_GPIO_MP221,
+	S5PC110_GPIO_MP222,
+	S5PC110_GPIO_MP223,
+	S5PC110_GPIO_MP224,
+	S5PC110_GPIO_MP225,
+	S5PC110_GPIO_MP226,
+	S5PC110_GPIO_MP227,
+	S5PC110_GPIO_MP230,
+	S5PC110_GPIO_MP231,
+	S5PC110_GPIO_MP232,
+	S5PC110_GPIO_MP233,
+	S5PC110_GPIO_MP234,
+	S5PC110_GPIO_MP235,
+	S5PC110_GPIO_MP236,
+	S5PC110_GPIO_MP237,
+	S5PC110_GPIO_MP240,
+	S5PC110_GPIO_MP241,
+	S5PC110_GPIO_MP242,
+	S5PC110_GPIO_MP243,
+	S5PC110_GPIO_MP244,
+	S5PC110_GPIO_MP245,
+	S5PC110_GPIO_MP246,
+	S5PC110_GPIO_MP247,
+	S5PC110_GPIO_MP250,
+	S5PC110_GPIO_MP251,
+	S5PC110_GPIO_MP252,
+	S5PC110_GPIO_MP253,
+	S5PC110_GPIO_MP254,
+	S5PC110_GPIO_MP255,
+	S5PC110_GPIO_MP256,
+	S5PC110_GPIO_MP257,
+	S5PC110_GPIO_MP260,
+	S5PC110_GPIO_MP261,
+	S5PC110_GPIO_MP262,
+	S5PC110_GPIO_MP263,
+	S5PC110_GPIO_MP264,
+	S5PC110_GPIO_MP265,
+	S5PC110_GPIO_MP266,
+	S5PC110_GPIO_MP267,
+	S5PC110_GPIO_MP270,
+	S5PC110_GPIO_MP271,
+	S5PC110_GPIO_MP272,
+	S5PC110_GPIO_MP273,
+	S5PC110_GPIO_MP274,
+	S5PC110_GPIO_MP275,
+	S5PC110_GPIO_MP276,
+	S5PC110_GPIO_MP277,
+	S5PC110_GPIO_MP280,
+	S5PC110_GPIO_MP281,
+	S5PC110_GPIO_MP282,
+	S5PC110_GPIO_MP283,
+	S5PC110_GPIO_MP284,
+	S5PC110_GPIO_MP285,
+	S5PC110_GPIO_MP286,
+	S5PC110_GPIO_MP287,
+	S5PC110_GPIO_H00,
+	S5PC110_GPIO_H01,
+	S5PC110_GPIO_H02,
+	S5PC110_GPIO_H03,
+	S5PC110_GPIO_H04,
+	S5PC110_GPIO_H05,
+	S5PC110_GPIO_H06,
+	S5PC110_GPIO_H07,
+	S5PC110_GPIO_H10,
+	S5PC110_GPIO_H11,
+	S5PC110_GPIO_H12,
+	S5PC110_GPIO_H13,
+	S5PC110_GPIO_H14,
+	S5PC110_GPIO_H15,
+	S5PC110_GPIO_H16,
+	S5PC110_GPIO_H17,
+	S5PC110_GPIO_H20,
+	S5PC110_GPIO_H21,
+	S5PC110_GPIO_H22,
+	S5PC110_GPIO_H23,
+	S5PC110_GPIO_H24,
+	S5PC110_GPIO_H25,
+	S5PC110_GPIO_H26,
+	S5PC110_GPIO_H27,
+	S5PC110_GPIO_H30,
+	S5PC110_GPIO_H31,
+	S5PC110_GPIO_H32,
+	S5PC110_GPIO_H33,
+	S5PC110_GPIO_H34,
+	S5PC110_GPIO_H35,
+	S5PC110_GPIO_H36,
+	S5PC110_GPIO_H37,
+
+	S5PC110_GPIO_MAX_PORT
+};
+
+struct gpio_info {
+	unsigned int reg_addr;	/* Address of register for this part */
+	unsigned int max_gpio;	/* Maximum GPIO in this part */
+};
+
+#define S5PC100_GPIO_NUM_PARTS	1
+static struct gpio_info s5pc100_gpio_data[S5PC100_GPIO_NUM_PARTS] = {
+	{ S5PC100_GPIO_BASE, S5PC100_GPIO_MAX_PORT },
+};
+
+#define S5PC110_GPIO_NUM_PARTS	1
+static struct gpio_info s5pc110_gpio_data[S5PC110_GPIO_NUM_PARTS] = {
+	{ S5PC110_GPIO_BASE, S5PC110_GPIO_MAX_PORT },
+};
+
+static inline struct gpio_info *get_gpio_data(void)
+{
+	if (cpu_is_s5pc100())
+		return s5pc100_gpio_data;
+	else if (cpu_is_s5pc110())
+		return s5pc110_gpio_data;
+
+	return NULL;
+}
+
+static inline unsigned int get_bank_num(void)
+{
+	if (cpu_is_s5pc100())
+		return S5PC100_GPIO_NUM_PARTS;
+	else if (cpu_is_s5pc110())
+		return S5PC110_GPIO_NUM_PARTS;
+
+	return 0;
+}
+
+/*
+ * This structure helps mapping symbolic GPIO names into indices from
+ * exynos5_gpio_pin/exynos5420_gpio_pin enums.
+ *
+ * By convention, symbolic GPIO name is defined as follows:
+ *
+ * g[p]<bank><set><bit>, where
+ *   p is optional
+ *   <bank> - a single character bank name, as defined by the SOC
+ *   <set> - a single digit set number
+ *   <bit> - bit number within the set (in 0..7 range).
+ *
+ * <set><bit> essentially form an octal number of the GPIO pin within the bank
+ * space. On the 5420 architecture some banks' sets do not start not from zero
+ * ('d' starts from 1 and 'j' starts from 4). To compensate for that and
+ * maintain flat number space withoout holes, those banks use offsets to be
+ * deducted from the pin number.
+ */
+struct gpio_name_num_table {
+	char bank;		/* bank name symbol */
+	u8 bank_size;		/* total number of pins in the bank */
+	char bank_offset;	/* offset of the first bank's pin */
+	unsigned int base;	/* index of the first bank's pin in the enum */
+};
+
+#define GPIO_PER_BANK 8
+#define GPIO_ENTRY(name, base, top, offset) { name, top - base, offset, base }
+static const struct gpio_name_num_table s5pc100_gpio_table[] = {
+	GPIO_ENTRY('a', S5PC100_GPIO_A00, S5PC100_GPIO_B0, 0),
+	GPIO_ENTRY('b', S5PC100_GPIO_B0, S5PC100_GPIO_C0, 0),
+	GPIO_ENTRY('c', S5PC100_GPIO_C0, S5PC100_GPIO_D0, 0),
+	GPIO_ENTRY('d', S5PC100_GPIO_D0, S5PC100_GPIO_E00, 0),
+	GPIO_ENTRY('e', S5PC100_GPIO_E00, S5PC100_GPIO_F00, 0),
+	GPIO_ENTRY('f', S5PC100_GPIO_F00, S5PC100_GPIO_G00, 0),
+	GPIO_ENTRY('g', S5PC100_GPIO_G00, S5PC100_GPIO_I0, 0),
+	GPIO_ENTRY('i', S5PC100_GPIO_I0, S5PC100_GPIO_J00, 0),
+	GPIO_ENTRY('j', S5PC100_GPIO_J00, S5PC100_GPIO_K00, 0),
+	GPIO_ENTRY('k', S5PC100_GPIO_K00, S5PC100_GPIO_L00, 0),
+	GPIO_ENTRY('l', S5PC100_GPIO_L00, S5PC100_GPIO_H00, 0),
+	GPIO_ENTRY('h', S5PC100_GPIO_H00, S5PC100_GPIO_MAX_PORT, 0),
+	{ 0 }
+};
+
+static const struct gpio_name_num_table s5pc110_gpio_table[] = {
+	GPIO_ENTRY('a', S5PC110_GPIO_A00, S5PC110_GPIO_B0, 0),
+	GPIO_ENTRY('b', S5PC110_GPIO_B0, S5PC110_GPIO_C00, 0),
+	GPIO_ENTRY('c', S5PC110_GPIO_C00, S5PC110_GPIO_D00, 0),
+	GPIO_ENTRY('d', S5PC110_GPIO_D00, S5PC110_GPIO_E00, 0),
+	GPIO_ENTRY('e', S5PC110_GPIO_E00, S5PC110_GPIO_F00, 0),
+	GPIO_ENTRY('f', S5PC110_GPIO_F00, S5PC110_GPIO_G00, 0),
+	GPIO_ENTRY('g', S5PC110_GPIO_G00, S5PC110_GPIO_I0, 0),
+	GPIO_ENTRY('i', S5PC110_GPIO_I0, S5PC110_GPIO_J00, 0),
+	GPIO_ENTRY('j', S5PC110_GPIO_J00, S5PC110_GPIO_MP010, 0),
+	GPIO_ENTRY('h', S5PC110_GPIO_H00, S5PC110_GPIO_MAX_PORT, 0),
+	{ 0 }
+};
+
+/* functions */
+void gpio_cfg_pin(int gpio, int cfg);
+void gpio_set_pull(int gpio, int mode);
+void gpio_set_drv(int gpio, int mode);
+void gpio_set_rate(int gpio, int mode);
+int s5p_gpio_get_pin(unsigned gpio);
+
+/* GPIO pins per bank  */
+#define GPIO_PER_BANK 8
+#endif
+
+/* Pin configurations */
+#define S5P_GPIO_INPUT	0x0
+#define S5P_GPIO_OUTPUT	0x1
+#define S5P_GPIO_IRQ	0xf
+#define S5P_GPIO_FUNC(x)	(x)
+
+/* Pull mode */
+#define S5P_GPIO_PULL_NONE	0x0
+#define S5P_GPIO_PULL_DOWN	0x1
+#define S5P_GPIO_PULL_UP	0x2
+
+/* Drive Strength level */
+#define S5P_GPIO_DRV_1X	0x0
+#define S5P_GPIO_DRV_3X	0x1
+#define S5P_GPIO_DRV_2X	0x2
+#define S5P_GPIO_DRV_4X	0x3
+#define S5P_GPIO_DRV_FAST	0x0
+#define S5P_GPIO_DRV_SLOW	0x1
+
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/mmc.h b/u-boot/arch/arm/mach-s5pv210/include/mach/mmc.h
new file mode 100644
index 0000000..7078790
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/mmc.h
@@ -0,0 +1,64 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2009 SAMSUNG Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ */
+
+#ifndef __ASM_ARCH_MMC_H_
+#define __ASM_ARCH_MMC_H_
+
+#define S5P_MMC_DEV_OFFSET	0x100000
+
+#define SDHCI_CONTROL2		0x80
+#define SDHCI_CONTROL3		0x84
+#define SDHCI_CONTROL4		0x8C
+
+#define SDHCI_CTRL2_ENSTAASYNCCLR	(1 << 31)
+#define SDHCI_CTRL2_ENCMDCNFMSK		(1 << 30)
+#define SDHCI_CTRL2_CDINVRXD3		(1 << 29)
+#define SDHCI_CTRL2_SLCARDOUT		(1 << 28)
+
+#define SDHCI_CTRL2_FLTCLKSEL_MASK	(0xf << 24)
+#define SDHCI_CTRL2_FLTCLKSEL_SHIFT	(24)
+#define SDHCI_CTRL2_FLTCLKSEL(_x)	((_x) << 24)
+
+#define SDHCI_CTRL2_LVLDAT_MASK		(0xff << 16)
+#define SDHCI_CTRL2_LVLDAT_SHIFT	(16)
+#define SDHCI_CTRL2_LVLDAT(_x)		((_x) << 16)
+
+#define SDHCI_CTRL2_ENFBCLKTX		(1 << 15)
+#define SDHCI_CTRL2_ENFBCLKRX		(1 << 14)
+#define SDHCI_CTRL2_SDCDSEL		(1 << 13)
+#define SDHCI_CTRL2_SDSIGPC		(1 << 12)
+#define SDHCI_CTRL2_ENBUSYCHKTXSTART	(1 << 11)
+
+#define SDHCI_CTRL2_DFCNT_MASK(_x)	((_x) << 9)
+#define SDHCI_CTRL2_DFCNT_SHIFT		(9)
+
+#define SDHCI_CTRL2_ENCLKOUTHOLD	(1 << 8)
+#define SDHCI_CTRL2_RWAITMODE		(1 << 7)
+#define SDHCI_CTRL2_DISBUFRD		(1 << 6)
+#define SDHCI_CTRL2_SELBASECLK_MASK(_x)	((_x) << 4)
+#define SDHCI_CTRL2_SELBASECLK_SHIFT	(4)
+#define SDHCI_CTRL2_PWRSYNC		(1 << 3)
+#define SDHCI_CTRL2_ENCLKOUTMSKCON	(1 << 1)
+#define SDHCI_CTRL2_HWINITFIN		(1 << 0)
+
+#define SDHCI_CTRL3_FCSEL3		(1 << 31)
+#define SDHCI_CTRL3_FCSEL2		(1 << 23)
+#define SDHCI_CTRL3_FCSEL1		(1 << 15)
+#define SDHCI_CTRL3_FCSEL0		(1 << 7)
+
+#define SDHCI_CTRL4_DRIVE_MASK(_x)	((_x) << 16)
+#define SDHCI_CTRL4_DRIVE_SHIFT		(16)
+
+int s5p_sdhci_init(u32 regbase, int index, int bus_width);
+
+static inline int s5p_mmc_init(int index, int bus_width)
+{
+	unsigned int base = samsung_get_base_mmc() +
+				 (S5P_MMC_DEV_OFFSET * index);
+
+	return s5p_sdhci_init(base, index, bus_width);
+}
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/periph.h b/u-boot/arch/arm/mach-s5pv210/include/mach/periph.h
new file mode 100644
index 0000000..bb73d72
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/periph.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2012 Samsung Electronics
+ * Rajeshwari Shinde <rajeshwari.s@samsung.com>
+ */
+
+#ifndef __ASM_ARM_ARCH_PERIPH_H
+#define __ASM_ARM_ARCH_PERIPH_H
+
+/*
+ * Peripherals required for pinmux configuration. List will
+ * grow with support for more devices getting added.
+ * Numbering based on interrupt table.
+ *
+ */
+enum periph_id {
+	PERIPH_ID_UART0 = 51,
+	PERIPH_ID_UART1,
+	PERIPH_ID_UART2,
+	PERIPH_ID_UART3,
+	PERIPH_ID_I2C0 = 56,
+	PERIPH_ID_I2C1,
+	PERIPH_ID_I2C2,
+	PERIPH_ID_I2C3,
+	PERIPH_ID_I2C4,
+	PERIPH_ID_I2C5,
+	PERIPH_ID_I2C6,
+	PERIPH_ID_I2C7,
+	PERIPH_ID_SPI0 = 68,
+	PERIPH_ID_SPI1,
+	PERIPH_ID_SPI2,
+	PERIPH_ID_SDMMC0 = 75,
+	PERIPH_ID_SDMMC1,
+	PERIPH_ID_SDMMC2,
+	PERIPH_ID_SDMMC3,
+	PERIPH_ID_I2C8 = 87,
+	PERIPH_ID_I2C9,
+	PERIPH_ID_I2S0 = 98,
+	PERIPH_ID_I2S1 = 99,
+
+	/* Since following peripherals do
+	 * not have shared peripheral interrupts (SPIs)
+	 * they are numbered arbitiraly after the maximum
+	 * SPIs Exynos has (128)
+	 */
+	PERIPH_ID_SROMC = 128,
+	PERIPH_ID_SPI3,
+	PERIPH_ID_SPI4,
+	PERIPH_ID_SDMMC4,
+	PERIPH_ID_PWM0,
+	PERIPH_ID_PWM1,
+	PERIPH_ID_PWM2,
+	PERIPH_ID_PWM3,
+	PERIPH_ID_PWM4,
+	PERIPH_ID_I2C10 = 203,
+
+	PERIPH_ID_NONE = -1,
+};
+
+#endif /* __ASM_ARM_ARCH_PERIPH_H */
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/pinmux.h b/u-boot/arch/arm/mach-s5pv210/include/mach/pinmux.h
new file mode 100644
index 0000000..075cdce
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/pinmux.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2012 Samsung Electronics
+ * Abhilash Kesavan <a.kesavan@samsung.com>
+ */
+
+#ifndef __ASM_ARM_ARCH_PINMUX_H
+#define __ASM_ARM_ARCH_PINMUX_H
+
+#include "periph.h"
+
+/*
+ * Flags for setting specific configarations of peripherals.
+ * List will grow with support for more devices getting added.
+ */
+enum {
+	PINMUX_FLAG_NONE	= 0x00000000,
+
+	/* Flags for eMMC */
+	PINMUX_FLAG_8BIT_MODE	= 1 << 0,       /* SDMMC 8-bit mode */
+
+	/* Flags for SROM controller */
+	PINMUX_FLAG_BANK	= 3 << 0,       /* bank number (0-3) */
+	PINMUX_FLAG_16BIT	= 1 << 2,       /* 16-bit width */
+};
+
+/**
+ * Configures the pinmux for a particular peripheral.
+ *
+ * Each gpio can be configured in many different ways (4 bits on exynos)
+ * such as "input", "output", "special function", "external interrupt"
+ * etc. This function will configure the peripheral pinmux along with
+ * pull-up/down and drive strength.
+ *
+ * @param peripheral	peripheral to be configured
+ * @param flags		configure flags
+ * @return 0 if ok, -1 on error (e.g. unsupported peripheral)
+ */
+int exynos_pinmux_config(int peripheral, int flags);
+
+/**
+ * Decode the peripheral id using the interrpt numbers.
+ *
+ * @param blob  Device tree blob
+ * @param node  FDT I2C node to find
+ * @return peripheral id if ok, PERIPH_ID_NONE on error
+ */
+int pinmux_decode_periph_id(const void *blob, int node);
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/power.h b/u-boot/arch/arm/mach-s5pv210/include/mach/power.h
new file mode 100644
index 0000000..e382e8e
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/power.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (c) 2009 Samsung Electronics
+ * Kyungmin Park <kyungmin.park@samsung.com>
+ * Minkyu Kang <mk7.kang@samsung.com>
+ */
+
+#ifndef __ASM_ARM_ARCH_POWER_H_
+#define __ASM_ARM_ARCH_POWER_H_
+
+/*
+ * Power control
+ */
+#define S5PC100_OTHERS			0xE0108200
+#define S5PC100_RST_STAT		0xE0108300
+#define S5PC100_SLEEP_WAKEUP		(1 << 3)
+#define S5PC100_WAKEUP_STAT		0xE0108304
+#define S5PC100_INFORM0			0xE0108400
+
+#define S5PC110_RST_STAT		0xE010A000
+#define S5PC110_SLEEP_WAKEUP		(1 << 3)
+#define S5PC110_WAKEUP_STAT		0xE010C200
+#define S5PC110_OTHERS			0xE010E000
+#define S5PC110_USB_PHY_CON		0xE010E80C
+#define S5PC110_INFORM0			0xE010F000
+
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/pwm.h b/u-boot/arch/arm/mach-s5pv210/include/mach/pwm.h
new file mode 100644
index 0000000..1a531be
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/pwm.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2009 Samsung Electronics
+ * Kyungmin Park <kyungmin.park@samsung.com>
+ * Minkyu Kang <mk7.kang@samsung.com>
+ */
+
+#ifndef __ASM_ARM_ARCH_PWM_H_
+#define __ASM_ARM_ARCH_PWM_H_
+
+#define PRESCALER_0		(8 - 1)		/* prescaler of timer 0, 1 */
+#define PRESCALER_1		(16 - 1)	/* prescaler of timer 2, 3, 4 */
+
+/* Divider MUX */
+#define MUX_DIV_1		0		/* 1/1 period */
+#define MUX_DIV_2		1		/* 1/2 period */
+#define MUX_DIV_4		2		/* 1/4 period */
+#define MUX_DIV_8		3		/* 1/8 period */
+#define MUX_DIV_16		4		/* 1/16 period */
+
+#define MUX_DIV_SHIFT(x)	(x * 4)
+
+#define TCON_OFFSET(x)		((x + 1) * (!!x) << 2)
+
+#define TCON_START(x)		(1 << TCON_OFFSET(x))
+#define TCON_UPDATE(x)		(1 << (TCON_OFFSET(x) + 1))
+#define TCON_INVERTER(x)	(1 << (TCON_OFFSET(x) + 2))
+#define TCON_AUTO_RELOAD(x)	(1 << (TCON_OFFSET(x) + 3))
+#define TCON4_AUTO_RELOAD	(1 << 22)
+
+#ifndef __ASSEMBLY__
+struct s5p_timer {
+	unsigned int	tcfg0;
+	unsigned int	tcfg1;
+	unsigned int	tcon;
+	unsigned int	tcntb0;
+	unsigned int	tcmpb0;
+	unsigned int	tcnto0;
+	unsigned int	tcntb1;
+	unsigned int	tcmpb1;
+	unsigned int	tcnto1;
+	unsigned int	tcntb2;
+	unsigned int	tcmpb2;
+	unsigned int	tcnto2;
+	unsigned int	tcntb3;
+	unsigned int	res1;
+	unsigned int	tcnto3;
+	unsigned int	tcntb4;
+	unsigned int	tcnto4;
+	unsigned int	tintcstat;
+};
+#endif	/* __ASSEMBLY__ */
+
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/sromc.h b/u-boot/arch/arm/mach-s5pv210/include/mach/sromc.h
new file mode 100644
index 0000000..45de4a7
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/sromc.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2010 Samsung Electronics
+ * Naveen Krishna Ch <ch.naveen@samsung.com>
+ *
+ * Note: This file contains the register description for Memory subsystem
+ * 	 (SROM, NAND Flash, OneNand, DDR, OneDRAM) on S5PC1XX.
+ *
+ * 	 Only SROMC is defined as of now
+ */
+
+#ifndef __ASM_ARCH_SROMC_H_
+#define __ASM_ARCH_SROMC_H_
+
+#define SMC_DATA16_WIDTH(x)    (1<<((x*4)+0))
+#define SMC_BYTE_ADDR_MODE(x)  (1<<((x*4)+1))  /* 0-> Half-word base address*/
+						/* 1-> Byte base address*/
+#define SMC_WAIT_ENABLE(x)     (1<<((x*4)+2))
+#define SMC_BYTE_ENABLE(x)     (1<<((x*4)+3))
+
+#define SMC_BC_TACS(x) (x << 28) /* 0clk     address set-up */
+#define SMC_BC_TCOS(x) (x << 24) /* 4clk     chip selection set-up */
+#define SMC_BC_TACC(x) (x << 16) /* 14clk    access cycle */
+#define SMC_BC_TCOH(x) (x << 12) /* 1clk     chip selection hold */
+#define SMC_BC_TAH(x)  (x << 8)  /* 4clk     address holding time */
+#define SMC_BC_TACP(x) (x << 4)  /* 6clk     page mode access cycle */
+#define SMC_BC_PMC(x)  (x << 0)  /* normal(1data)page mode configuration */
+
+#ifndef __ASSEMBLY__
+struct s5p_sromc {
+	unsigned int	bw;
+	unsigned int	bc[6];
+};
+#endif	/* __ASSEMBLY__ */
+
+/* Configure the Band Width and Bank Control Regs for required SROMC Bank */
+void s5p_config_sromc(u32 srom_bank, u32 srom_bw_conf, u32 srom_bc_conf);
+
+#endif /* __ASM_ARCH_SMC_H_ */
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/sys_proto.h b/u-boot/arch/arm/mach-s5pv210/include/mach/sys_proto.h
new file mode 100644
index 0000000..89de400
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/sys_proto.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2009 Samsung Electrnoics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ */
+
+#ifndef _SYS_PROTO_H_
+#define _SYS_PROTO_H_
+
+u32 get_device_type(void);
+
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/uart.h b/u-boot/arch/arm/mach-s5pv210/include/mach/uart.h
new file mode 100644
index 0000000..6618981
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/uart.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2009 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * Heungjun Kim <riverful.kim@samsung.com>
+ */
+
+#ifndef __ASM_ARCH_UART_H_
+#define __ASM_ARCH_UART_H_
+
+#ifndef __ASSEMBLY__
+/* baudrate rest value */
+union br_rest {
+	unsigned short	slot;		/* udivslot */
+	unsigned char	value;		/* ufracval */
+};
+
+struct s5p_uart {
+	unsigned int	ulcon;
+	unsigned int	ucon;
+	unsigned int	ufcon;
+	unsigned int	umcon;
+	unsigned int	utrstat;
+	unsigned int	uerstat;
+	unsigned int	ufstat;
+	unsigned int	umstat;
+	unsigned char	utxh;
+	unsigned char	res1[3];
+	unsigned char	urxh;
+	unsigned char	res2[3];
+	unsigned int	ubrdiv;
+	union br_rest	rest;
+	unsigned char	res3[0x3d0];
+};
+
+static inline int s5p_uart_divslot(void)
+{
+	return 1;
+}
+
+#endif	/* __ASSEMBLY__ */
+
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/include/mach/watchdog.h b/u-boot/arch/arm/mach-s5pv210/include/mach/watchdog.h
new file mode 100644
index 0000000..81b8b0f
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/include/mach/watchdog.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2011 Samsung Electronics
+ * Heungjun Kim <riverful.kim@samsung.com>
+ * Minkyu Kang <mk7.kang@samsung.com>
+ */
+
+#ifndef __ASM_ARM_ARCH_WATCHDOG_H_
+#define __ASM_ARM_ARCH_WATCHDOG_H_
+
+#define WTCON_RESET_OFFSET	0
+#define WTCON_INTEN_OFFSET	2
+#define WTCON_CLKSEL_OFFSET	3
+#define WTCON_EN_OFFSET		5
+#define WTCON_PRE_OFFSET	8
+
+#define WTCON_CLK_16		0x0
+#define WTCON_CLK_32		0x1
+#define WTCON_CLK_64		0x2
+#define WTCON_CLK_128		0x3
+
+#define WTCON_CLK(x)		((x & 0x3) << WTCON_CLKSEL_OFFSET)
+#define WTCON_PRESCALER(x)	((x) << WTCON_PRE_OFFSET)
+#define WTCON_EN		(0x1 << WTCON_EN_OFFSET)
+#define WTCON_RESET		(0x1 << WTCON_RESET_OFFSET)
+#define WTCON_INT		(0x1 << WTCON_INTEN_OFFSET)
+
+#ifndef __ASSEMBLY__
+struct s5p_watchdog {
+	unsigned int wtcon;
+	unsigned int wtdat;
+	unsigned int wtcnt;
+	unsigned int wtclrint;
+};
+
+/* functions */
+void wdt_stop(void);
+void wdt_start(unsigned int timeout);
+#endif	/* __ASSEMBLY__ */
+
+#endif
diff --git a/u-boot/arch/arm/mach-s5pv210/pinmux.c b/u-boot/arch/arm/mach-s5pv210/pinmux.c
new file mode 100644
index 0000000..818d751
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/pinmux.c
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Dummy functions to keep s5p_goni building (although it won't work)
+ *
+ * Copyright 2018 Google LLC
+ * Written by Simon Glass <sjg@chromium.org>
+ */
+
+#include <common.h>
+#include <asm/arch/pinmux.h>
+
+int exynos_pinmux_config(int peripheral, int flags)
+{
+	return 0;
+}
+
+int pinmux_decode_periph_id(const void *blob, int node)
+{
+	return 0;
+}
diff --git a/u-boot/arch/arm/mach-s5pv210/reset.S b/u-boot/arch/arm/mach-s5pv210/reset.S
new file mode 100644
index 0000000..aac1ea0
--- /dev/null
+++ b/u-boot/arch/arm/mach-s5pv210/reset.S
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (c) 2009 Samsung Electronics.
+ * Minkyu Kang <mk7.kang@samsung.com>
+ */
+
+#include <asm/arch/cpu.h>
+#include <linux/linkage.h>
+
+#define S5PC100_SWRESET			0xE0200000
+#define S5PC110_SWRESET			0xE0102000
+
+ENTRY(reset_cpu)
+	ldr	r1, =S5PC100_PRO_ID
+	ldr	r2, [r1]
+	ldr	r4, =0x00010000
+	and	r4, r2, r4
+	cmp	r4, #0
+	bne	110f
+	/* S5PC100 */
+	ldr	r1, =S5PC100_SWRESET
+	ldr	r2, =0xC100
+	b	200f
+110:	/* S5PC110 */
+	ldr	r1, =S5PC110_SWRESET
+	mov	r2, #1
+200:
+	str	r2, [r1]
+_loop_forever:
+	b	_loop_forever
+ENDPROC(reset_cpu)
diff --git a/u-boot/board/samsung/smart210/Kconfig b/u-boot/board/samsung/smart210/Kconfig
new file mode 100644
index 0000000..423d1e6
--- /dev/null
+++ b/u-boot/board/samsung/smart210/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_SMART210
+
+config SYS_BOARD
+	default "smart210"
+
+config SYS_VENDOR
+	default "samsung"
+
+config SYS_SOC
+	default "s5pv210"
+
+config SYS_CONFIG_NAME
+	default "smart210"
+
+endif
diff --git a/u-boot/board/samsung/smart210/MAINTAINERS b/u-boot/board/samsung/smart210/MAINTAINERS
new file mode 100644
index 0000000..d647113
--- /dev/null
+++ b/u-boot/board/samsung/smart210/MAINTAINERS
@@ -0,0 +1,6 @@
+SMDKC100 BOARD
+M:	Minkyu Kang <mk7.kang@samsung.com>
+S:	Maintained
+F:	board/samsung/smart210/
+F:	include/configs/smart210.h
+F:	configs/smart210_defconfig
diff --git a/u-boot/board/samsung/smart210/Makefile b/u-boot/board/samsung/smart210/Makefile
new file mode 100644
index 0000000..4d89cc8
--- /dev/null
+++ b/u-boot/board/samsung/smart210/Makefile
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2008
+# Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+
+obj-y	:= smart210.o
+obj-$(CONFIG_SAMSUNG_ONENAND)	+= onenand.o
+obj-y	+= lowlevel_init.o
diff --git a/u-boot/board/samsung/smart210/lowlevel_init.S b/u-boot/board/samsung/smart210/lowlevel_init.S
new file mode 100644
index 0000000..fb03049
--- /dev/null
+++ b/u-boot/board/samsung/smart210/lowlevel_init.S
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2009 Samsung Electronics
+ * Kyungmin Park <kyungmin.park@samsung.com>
+ * Minkyu Kang <mk7.kang@samsung.com>
+ */
+
+#include <config.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/power.h>
+
+/*
+ * Register usages:
+ *
+ * r5 has zero always
+ */
+
+	.globl lowlevel_init
+lowlevel_init:
+	mov	r9, lr
+
+#ifdef CONFIG_SPL_BUILD
+        bl clock_init                   /* clock init */
+        bl ddr_init                     /* DDR init */
+
+        /* add by Flinn, for uart */
+        ldr r0, =0xE0200000     /* GPA0_CON */
+        ldr     r1, =0x22222222
+        str     r1, [r0]
+
+#endif
+        mov     pc, r9                /* return */
\ No newline at end of file
diff --git a/u-boot/board/samsung/smart210/onenand.c b/u-boot/board/samsung/smart210/onenand.c
new file mode 100644
index 0000000..04dc04a
--- /dev/null
+++ b/u-boot/board/samsung/smart210/onenand.c
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2008-2009 Samsung Electronics
+ * Kyungmin Park <kyungmin.park@samsung.com>
+ */
+
+#include <common.h>
+#include <linux/compat.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/onenand.h>
+#include <linux/mtd/samsung_onenand.h>
+
+#include <onenand_uboot.h>
+
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+
+int onenand_board_init(struct mtd_info *mtd)
+{
+	struct onenand_chip *this = mtd->priv;
+	struct s5pc100_clock *clk =
+			(struct s5pc100_clock *)samsung_get_base_clock();
+	struct samsung_onenand *onenand;
+	int value;
+
+	this->base = (void *)S5PC100_ONENAND_BASE;
+	onenand = (struct samsung_onenand *)this->base;
+
+	/* D0 Domain memory clock gating */
+	value = readl(&clk->gate_d01);
+	value &= ~(1 << 2);		/* CLK_ONENANDC */
+	value |= (1 << 2);
+	writel(value, &clk->gate_d01);
+
+	value = readl(&clk->src0);
+	value &= ~(1 << 24);		/* MUX_1nand: 0 from HCLKD0 */
+	value &= ~(1 << 20);		/* MUX_HREF: 0 from FIN_27M */
+	writel(value, &clk->src0);
+
+	value = readl(&clk->div1);
+	value &= ~(3 << 16);		/* PCLKD1_RATIO */
+	value |= (1 << 16);
+	writel(value, &clk->div1);
+
+	writel(ONENAND_MEM_RESET_COLD, &onenand->mem_reset);
+
+	while (!(readl(&onenand->int_err_stat) & RST_CMP))
+		continue;
+
+	writel(RST_CMP, &onenand->int_err_ack);
+
+	/*
+	 * Access_Clock [2:0]
+	 * 166 MHz, 134 Mhz : 3
+	 * 100 Mhz, 60 Mhz  : 2
+	 */
+	writel(0x3, &onenand->acc_clock);
+
+	writel(INT_ERR_ALL, &onenand->int_err_mask);
+	writel(1 << 0, &onenand->int_pin_en);	/* Enable */
+
+	value = readl(&onenand->int_err_mask);
+	value &= ~RDY_ACT;
+	writel(value, &onenand->int_err_mask);
+
+	s3c_onenand_init(mtd);
+
+	return 0;
+}
diff --git a/u-boot/board/samsung/smart210/smart210.c b/u-boot/board/samsung/smart210/smart210.c
new file mode 100644
index 0000000..19c1a94
--- /dev/null
+++ b/u-boot/board/samsung/smart210/smart210.c
@@ -0,0 +1,190 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ *  Copyright (C) 2008-2009 Samsung Electronics
+ *  Minkyu Kang <mk7.kang@samsung.com>
+ *  Kyungmin Park <kyungmin.park@samsung.com>
+ */
+
+#include <common.h>
+#include <init.h>
+#include <net.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <asm/arch/sromc.h>
+#include <netdev.h>
+#include <asm/mach-types.h>
+
+#ifndef CONFIG_SPL_BUILD        /* add by Flinn */
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+int board_init(void)
+{
+	gd->bd->bi_arch_number = MACH_TYPE_SMART210;
+	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = get_ram_size((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE);
+
+	return 0;
+}
+
+int dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
+
+#ifdef CONFIG_DISPLAY_BOARDINFO
+int checkboard(void)
+{
+	printf("Board:\tSMART210\n");
+	return 0;
+}
+#endif
+
+#else
+
+void clock_init(void)
+{
+    u32 val = 0;
+
+    struct s5pv210_clock *const clock = (struct s5pv210_clock *)samsung_get_base_clock();
+
+    writel(0xFFFF, &clock->apll_lock);
+    writel(0xFFFF, &clock->mpll_lock);
+    writel(0xFFFF, &clock->epll_lock);
+    writel(0xFFFF, &clock->vpll_lock);
+
+    writel((3  << 8) | (125 << 16) | (1 << 0) | (1 << 31), &clock->apll_con0);      /* FOUT_APLL = 1000MHz */
+    writel((12 << 8) | (667 << 16) | (1 << 0) | (1 << 31), &clock->mpll_con);       /* FOUT_MPLL = 667MHz */
+    writel((3  << 8) | (48  << 16) | (2 << 0) | (1 << 31), &clock->epll_con0);      /* FOUT_EPLL = 96MHz */
+    writel((6  << 8) | (108 << 16) | (3 << 0) | (1 << 31), &clock->vpll_con);       /* FOUT_VPLL = 54MHz */
+
+    while (!(readl(&clock->apll_con0) & (1 << 29)));
+    while (!(readl(&clock->mpll_con) & (1 << 29)));
+    while (!(readl(&clock->apll_con0) & (1 << 29)));
+    while (!(readl(&clock->epll_con0) & (1 << 29)));
+    while (!(readl(&clock->vpll_con) & (1 << 29)));
+
+    writel((1 << 0) | (1 << 4) | (1 << 8) | (1 << 12), &clock->src0);
+
+    val =   (0 << 0)  |     /* APLL_RATIO = 0, freq(ARMCLK) = MOUT_MSYS / (APLL_RATIO + 1) = 1000MHz */
+            (4 << 4)  |     /* A2M_RATIO = 4, freq(A2M) = SCLKAPLL / (A2M_RATIO + 1) = 200MHz */
+            (4 << 8)  |     /* HCLK_MSYS_RATIO = 4, freq(HCLK_MSYS) = ARMCLK / (HCLK_MSYS_RATIO + 1) = 200MHz */
+            (1 << 12) |     /* PCLK_MSYS_RATIO = 1, freq(PCLK_MSYS) = HCLK_MSYS / (PCLK_MSYS_RATIO + 1) = 100MHz */
+            (3 << 16) | /* HCLK_DSYS_RATIO = 3, freq(HCLK_DSYS) = MOUT_DSYS / (HCLK_DSYS_RATIO + 1) = 166MHz */
+            (1 << 20) | /* PCLK_DSYS_RATIO = 1, freq(PCLK_DSYS) = HCLK_DSYS / (PCLK_DSYS_RATIO + 1) = 83MHz */
+            (4 << 24) |     /* HCLK_PSYS_RATIO = 4, freq(HCLK_PSYS) = MOUT_PSYS / (HCLK_PSYS_RATIO + 1) = 133MHz */
+            (1 << 28);      /* PCLK_PSYS_RATIO = 1, freq(PCLK_PSYS) = HCLK_PSYS / (PCLK_PSYS_RATIO + 1) = 66MHz */
+    writel(val, &clock->div0);
+}
+
+void ddr_init(void)
+{
+    struct s5pv210_dmc0 *const dmc0 = (struct s5pv210_dmc0 *)samsung_get_base_dmc0();
+    struct s5pv210_dmc1 *const dmc1 = (struct s5pv210_dmc1 *)samsung_get_base_dmc1();
+
+    /* DMC0 */
+    writel(0x00101000, &dmc0->phycontrol0);
+    writel(0x00101002, &dmc0->phycontrol0);                 /* DLL on */
+    writel(0x00000086, &dmc0->phycontrol1);
+    writel(0x00101003, &dmc0->phycontrol0);                 /* DLL start */
+
+    while ((readl(&dmc0->phystatus) & 0x7) != 0x7); /* wait DLL locked */
+
+    writel(0x0FFF2350, &dmc0->concontrol);                  /* Auto Refresh Counter should be off */
+    writel(0x00202430, &dmc0->memcontrol);                  /* Dynamic power down should be off */
+    writel(0x20E01323, &dmc0->memconfig0);
+
+    writel(0xFF000000, &dmc0->prechconfig);
+    writel(0xFFFF00FF, &dmc0->pwrdnconfig);
+
+    writel(0x00000618, &dmc0->timingaref);                  /* 7.8us * 200MHz = 1560 = 0x618  */
+    writel(0x19233309, &dmc0->timingrow);
+    writel(0x23240204, &dmc0->timingdata);
+    writel(0x09C80232, &dmc0->timingpower);
+
+    writel(0x07000000, &dmc0->directcmd);                   /* NOP */
+    writel(0x01000000, &dmc0->directcmd);                   /* PALL */
+    writel(0x00020000, &dmc0->directcmd);                   /* EMRS2 */
+    writel(0x00030000, &dmc0->directcmd);                   /* EMRS3 */
+    writel(0x00010400, &dmc0->directcmd);                   /* EMRS enable DLL */
+    writel(0x00000542, &dmc0->directcmd);                   /* DLL reset */
+    writel(0x01000000, &dmc0->directcmd);                   /* PALL */
+    writel(0x05000000, &dmc0->directcmd);                   /* auto refresh */
+    writel(0x05000000, &dmc0->directcmd);                   /* auto refresh */
+    writel(0x00000442, &dmc0->directcmd);                   /* DLL unreset */
+    writel(0x00010780, &dmc0->directcmd);                   /* OCD default */
+    writel(0x00010400, &dmc0->directcmd);                   /* OCD exit */
+
+    writel(0x0FF02030, &dmc0->concontrol);                  /* auto refresh on */
+    writel(0xFFFF00FF, &dmc0->pwrdnconfig);
+    writel(0x00202400, &dmc0->memcontrol);
+
+	/* DMC1 */
+    writel(0x00101000, &dmc1->phycontrol0);
+    writel(0x00101002, &dmc1->phycontrol0);                 /* DLL on */
+    writel(0x00000086, &dmc1->phycontrol1);
+    writel(0x00101003, &dmc1->phycontrol0);                 /* DLL start */
+
+    while ((readl(&dmc1->phystatus) & 0x7) != 0x7); /* wait DLL locked */
+
+    writel(0x0FFF2350, &dmc1->concontrol);                  /* Auto Refresh Counter should be off */
+    writel(0x00202430, &dmc1->memcontrol);                  /* Dynamic power down should be off */
+    writel(0x40E01323, &dmc1->memconfig0);
+
+    writel(0xFF000000, &dmc1->prechconfig);
+    writel(0xFFFF00FF, &dmc1->pwrdnconfig);
+
+    writel(0x00000618, &dmc1->timingaref);                  /* 7.8us * 200MHz = 1560 = 0x618  */
+    writel(0x19233309, &dmc1->timingrow);
+    writel(0x23240204, &dmc1->timingdata);
+    writel(0x09C80232, &dmc1->timingpower);
+
+    writel(0x07000000, &dmc1->directcmd);                   /* NOP */
+    writel(0x01000000, &dmc1->directcmd);                   /* PALL */
+    writel(0x00020000, &dmc1->directcmd);                   /* EMRS2 */
+    writel(0x00030000, &dmc1->directcmd);                   /* EMRS3 */
+    writel(0x00010400, &dmc1->directcmd);                   /* EMRS enable DLL */
+    writel(0x00000542, &dmc1->directcmd);                   /* DLL reset */
+    writel(0x01000000, &dmc1->directcmd);                   /* PALL */
+    writel(0x05000000, &dmc1->directcmd);                   /* auto refresh */
+    writel(0x05000000, &dmc1->directcmd);                   /* auto refresh */
+    writel(0x00000442, &dmc1->directcmd);                   /* DLL unreset */
+    writel(0x00010780, &dmc1->directcmd);                   /* OCD default */
+    writel(0x00010400, &dmc1->directcmd);                   /* OCD exit */
+
+    writel(0x0FF02030, &dmc1->concontrol);                  /* auto refresh on */
+    writel(0xFFFF00FF, &dmc1->pwrdnconfig);
+    writel(0x00202400, &dmc1->memcontrol);
+}
+
+void copy_bl2_to_ram(void)
+{
+#define CopySDMMCtoMem(ch, sb, bs, dst, i) \
+        (((u8(*)(int, u32, unsigned short, u32*, u8))\
+        (*((u32 *)0xD0037F98)))(ch, sb, bs, dst, i))
+
+        u32 bl2Size = 250 * 1024 / 512;       // 250K
+        u32 kernelSize = 2 * 1024 * 1024 / 512;  // 2M
+        u32 rootfsSize = 2 * 1024 * 1024 / 512;  // 2M
+
+        u32 V210_SDMMC_BASE = *(volatile u32 *)(0xD0037488);    // V210_SDMMC_BASE
+
+        if (V210_SDMMC_BASE == 0xEB000000) {
+            CopySDMMCtoMem(0, 32, bl2Size, (u32 *)CONFIG_SYS_SDRAM_BASE, 0);
+            CopySDMMCtoMem(0, 32 + bl2Size, kernelSize, (u32 *)CONFIG_SYS_SDRAM_KERNEL, 0);
+            CopySDMMCtoMem(0, 32 + bl2Size + kernelSize, rootfsSize, (u32 *)CONFIG_SYS_SDRAM_ROOTFS, 0);
+        }
+}
+#endif
diff --git a/u-boot/common/spl/Kconfig b/u-boot/common/spl/Kconfig
index d8086bd..dd8eafd 100644
--- a/u-boot/common/spl/Kconfig
+++ b/u-boot/common/spl/Kconfig
@@ -1,7 +1,9 @@
 menu "SPL / TPL"
 
 config SUPPORT_SPL
-	bool
+	bool "enable spl"
+    help
+      add by xcl
 
 config SUPPORT_TPL
 	bool
diff --git a/u-boot/configs/smart210.h b/u-boot/configs/smart210.h
new file mode 100644
index 0000000..b0002ba
--- /dev/null
+++ b/u-boot/configs/smart210.h
@@ -0,0 +1,149 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2009 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * HeungJun Kim <riverful.kim@samsung.com>
+ * Inki Dae <inki.dae@samsung.com>
+ *
+ * Configuation settings for the SAMSUNG SMDKC100 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_SAMSUNG		1	/* in a SAMSUNG core */
+#define CONFIG_S5P			1	/* which is in a S5P Family */
+#define CONFIG_S5PV210		1	/* which is in a S5PV210 */
+
+#include <asm/arch/cpu.h>		/* get chip and board defs */
+
+/* input clock of PLL: SMDKC100 has 12MHz input clock */
+#define CONFIG_SYS_CLK_FREQ		12000000
+
+/* DRAM Base */
+#define CONFIG_SYS_SDRAM_BASE		0x20000000
+
+/* Text Base */
+
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_INITRD_TAG
+
+/*
+ * Size of malloc() pool
+ * 1MB = 0x100000, 0x100000 = 1024 * 1024
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (1 << 20))
+
+/*
+ * select serial console configuration
+ */
+
+/* PWM */
+#define CONFIG_PWM			1
+
+#define CONFIG_BOOTCOMMAND	"run ramboot"
+
+#define CONFIG_RAMDISK_BOOT	"root=/dev/ram0 rw rootfstype=ext2" \
+				" console=ttySAC0,115200n8"
+
+#define CONFIG_COMMON_BOOT	"console=ttySAC0,115200n8" \
+				" mem=128M " \
+				" " CONFIG_MTDPARTS_DEFAULT
+
+#define CONFIG_UPDATEB	"updateb=onenand erase 0x0 0x40000;" \
+			" onenand write 0x32008000 0x0 0x40000\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	CONFIG_UPDATEB \
+	"updatek=" \
+		"onenand erase 0x60000 0x300000;" \
+		"onenand write 0x31008000 0x60000 0x300000\0" \
+	"updateu=" \
+		"onenand erase block 147-4095;" \
+		"onenand write 0x32000000 0x1260000 0x8C0000\0" \
+	"bootk=" \
+		"onenand read 0x30007FC0 0x60000 0x300000;" \
+		"bootm 0x30007FC0\0" \
+	"flashboot=" \
+		"set bootargs root=/dev/mtdblock${bootblock} " \
+		"rootfstype=${rootfstype} " \
+		"ubi.mtd=${ubiblock} ${opts} " CONFIG_COMMON_BOOT ";" \
+		"run bootk\0" \
+	"ubifsboot=" \
+		"set bootargs root=ubi0!rootfs rootfstype=ubifs " \
+		" ubi.mtd=${ubiblock} ${opts} " CONFIG_COMMON_BOOT "; " \
+		"run bootk\0" \
+	"boottrace=setenv opts initcall_debug; run bootcmd\0" \
+	"android=" \
+		"set bootargs root=ubi0!ramdisk ubi.mtd=${ubiblock} " \
+		"rootfstype=ubifs init=/init.sh " CONFIG_COMMON_BOOT "; " \
+		"run bootk\0" \
+	"nfsboot=" \
+		"set bootargs root=/dev/nfs ubi.mtd=${ubiblock} " \
+		"nfsroot=${nfsroot},nolock " \
+		"ip=${ipaddr}:${serverip}:${gatewayip}:" \
+		"${netmask}:nowplus:usb0:off " CONFIG_COMMON_BOOT "; " \
+		"run bootk\0" \
+	"ramboot=" \
+		"set bootargs " CONFIG_RAMDISK_BOOT \
+		" init=/linuxrc\0" \
+	"rootfstype=cramfs\0" \
+	"mtdparts=" CONFIG_MTDPARTS_DEFAULT "\0" \
+	"meminfo=mem=512M\0" \
+	"nfsroot=/nfsroot/arm\0" \
+	"bootblock=5\0" \
+	"ubiblock=4\0" \
+	"ubi=enabled"
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_PBSIZE	384	/* Print Buffer Size */
+/* memtest works on */
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+/* SMDKC100 has 1 banks of DRAM, we use only one in U-Boot */
+#define PHYS_SDRAM_1		CONFIG_SYS_SDRAM_BASE	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	(512 << 20)	/* 0x20900000, 512 MB Bank #1 */
+
+#define CONFIG_SYS_MONITOR_BASE	0x00000000
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+#define CONFIG_SYS_MONITOR_LEN		(256 << 10)	/* 256 KiB */
+
+#if !defined(CONFIG_NAND_SPL) && (CONFIG_SYS_TEXT_BASE >= 0xc0000000)
+#define CONFIG_ENABLE_MMU
+#endif
+
+#ifdef CONFIG_ENABLE_MMU
+#define CONFIG_SYS_MAPPED_RAM_BASE	0xc0000000
+#else
+#define CONFIG_SYS_MAPPED_RAM_BASE	CONFIG_SYS_SDRAM_BASE
+#endif
+
+/*-----------------------------------------------------------------------
+ * Boot configuration
+ */
+
+//#define CONFIG_USE_ONENAND_BOARD_INIT
+//#define CONFIG_SAMSUNG_ONENAND		1
+//#define CONFIG_SYS_ONENAND_BASE		0xE7100000
+
+#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_LOAD_ADDR - 0x1000000)
+
+/*
+ * Ethernet Contoller driver
+ */
+#ifdef CONFIG_CMD_NET
+#define CONFIG_ENV_SROM_BANK   1       /* Select SROM Bank-1 for Ethernet*/
+#endif /* CONFIG_CMD_NET */
+
+#endif	/* __CONFIG_H */
diff --git a/u-boot/configs/smart210_defconfig b/u-boot/configs/smart210_defconfig
new file mode 100644
index 0000000..721691f
--- /dev/null
+++ b/u-boot/configs/smart210_defconfig
@@ -0,0 +1,30 @@
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_S5PV210=y
+CONFIG_SYS_TEXT_BASE=0x20000000
+CONFIG_NR_DRAM_BANKS=1
+CONFIG_ENV_SIZE=0x20000
+CONFIG_TARGET_SMART210=y
+CONFIG_IDENT_STRING=" for SMART210"
+CONFIG_DEFAULT_DEVICE_TREE="s5pv210-smart210"
+CONFIG_BOOTDELAY=3
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="root=/dev/ram0 rw rootfstype=ext2 console=ttySAC0,115200n8 init=/linuxrc"
+CONFIG_HUSH_PARSER=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_SYS_PROMPT="SMART210 # "
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_ONENAND is not set
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_FAT=y
+# CONFIG_CMD_MTDPARTS is not set
+# CONFIG_MTDIDS_DEFAULT="onenand0=s3c-onenand"
+# CONFIG_MTDPARTS_DEFAULT="mtdparts=s3c-onenand:256k(bootloader),128k@0x40000(params),3m@0x60000(kernel),16m@0x360000(test),-(UBI)"
+# CONFIG_ENV_OVERWRITE is not set
+# CONFIG_ENV_IS_IN_ONENAND is not set
+# CONFIG_ENV_ADDR=0x40000
+# CONFIG_MMC is not set
+# CONFIG_MTD is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMC911X_BASE=0x98800300
-- 
2.7.4

